<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GOBLINS FAZ • Brand Studio</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest"></script>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<!-- CONTEXT MENU -->
<div id="ctxMenu" class="ctx-menu">
  <div class="ctx-item" data-action="rename"><i data-lucide="pencil-line"></i> Renomear</div>
  <div class="ctx-item" data-action="duplicate"><i data-lucide="copy"></i> Duplicar</div>
  <div class="ctx-divider"></div>
  <div class="ctx-item danger" data-action="delete"><i data-lucide="trash-2"></i> Excluir</div>
</div>

<!-- TOAST ROOT -->
<div id="toastRoot" class="toast-root"></div>

<!-- COLOR MODAL -->
<div id="modalBackdrop" class="modal-backdrop">
  <div class="modal" id="modal">
    <div class="modal-head">
      <div class="modal-head-title">Editar Cor</div>
      <button class="btn-icon" id="btnCloseModal">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
      </button>
    </div>
    <div class="modal-grid">
      <div class="modal-left">
        <div id="pickerCanvas" class="picker-canvas">
          <div id="pickerKnob" class="picker-knob"></div>
        </div>
        <div id="hueStrip" class="hue-strip">
          <div id="hueKnob" class="hue-knob"></div>
        </div>
        <div id="alphaStrip" class="alpha-strip">
          <div id="alphaFill" class="alpha-strip-fill"></div>
          <div id="alphaKnob" class="alpha-knob"></div>
        </div>
        <div id="colorPreviewSwatch" class="color-preview-swatch">
          <span id="colorPreviewLabel" style="font-family:'JetBrains Mono', ui-monospace, monospace;font-size:11px;color:rgba(255,255,255,.7)"></span>
        </div>
        <div class="history-dots" id="historyDots"></div>
      </div>
      <div class="modal-right">
        <div class="modal-field">
          <label>HEX</label>
          <input id="mHex" class="modal-inp" placeholder="#RRGGBB">
        </div>
        <div class="modal-field">
          <label>RGB</label>
          <input id="mRgb" class="modal-inp" placeholder="255, 0, 128">
        </div>
        <div class="modal-field">
          <label>Opac.</label>
          <input id="mAlpha" class="modal-inp" type="number" min="0" max="100">
        </div>
        <div class="modal-field">
          <label>Transparência</label>
          <input id="mAlphaRange" class="modal-inp" type="range" min="0" max="100" value="100">
        </div>
        <div class="modal-field">
          <label>% Uso</label>
          <input id="mPct" class="modal-inp" type="number" min="1" max="100">
        </div>
        <div class="modal-field">
          <label>Nome</label>
          <input id="mName" class="modal-inp" placeholder="Ex.: Azul Primário">
        </div>
        <div class="divider"></div>
        <div class="modal-field">
          <label>Copiar</label>
          <select id="mCopyMode" class="modal-sel">
            <option value="hex">HEX</option>
            <option value="rgb">RGB</option>
            <option value="rgba">RGBA</option>
            <option value="hsl">HSL</option>
            <option value="css">CSS var()</option>
          </select>
        </div>
        <div class="modal-foot">
          <button class="btn btn-ghost" id="btnCopyColor">Copiar</button>
          <button class="btn btn-danger" id="btnDeleteColor">Excluir</button>
          <button class="btn btn-primary" id="btnApplyColor">Aplicar</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- SHELL -->
<div class="shell">

  <!-- SIDEBAR -->
  <aside class="sidebar">
    <div class="sidebar-logo">
      <div class="dot">G</div>
      <div class="brand">Goblins Faz</div>
    </div>

    <div class="sidebar-section">
      <div class="sidebar-label">Principal</div>
      <div class="sidebar-item active" data-view="home" onclick="nav('home',this)">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
        Projetos
      </div>
    </div>

    <div class="sidebar-section" id="editorNav" style="display:none;">
      <div class="sidebar-label" id="editorNavLabel">Projeto</div>
      <div class="sidebar-item" data-view="editor" onclick="nav('editor',this)">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
        Editar
      </div>
      <div class="sidebar-item" data-view="board" onclick="nav('board',this)">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="14" rx="2"/><line x1="7" y1="21" x2="17" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/>
        </svg>
        Brand Board
      </div>
      <div class="sidebar-item" data-view="apps" onclick="nav('apps',this)">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="16" rx="2"/><line x1="7" y1="8" x2="17" y2="8"/><line x1="7" y1="12" x2="17" y2="12"/><line x1="7" y1="16" x2="13" y2="16"/>
        </svg>
        Aplicações
      </div>
<div class="sidebar-item" data-view="export" onclick="nav('export',this)">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/><path d="M9 18H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4"/></svg>
        Exportar
      </div>
    </div>

    <div class="sidebar-footer">
      <div class="version-tag">v2.0 • Brand Studio</div>
    </div>
  </aside>

  <!-- MAIN -->
  <div class="main">

    <!-- TOPBAR -->
    <div class="topbar">
      <div class="topbar-left">
        <div class="topbar-breadcrumb" id="breadcrumb">
          <span>Projetos</span>
        </div>
      </div>
      <div class="topbar-right" id="topbarRight"></div>
    </div>

    <!-- HOME VIEW -->
    <div id="viewHome" class="view active">
      <div class="home-head">
        <div>
          <h1>Seus Projetos</h1>
          <p>Gerencie identidades visuais das suas marcas.</p>
        </div>
        <button class="btn btn-primary" onclick="createProject()">
          <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
          Novo Projeto
        </button>
      </div>
      <div id="projGrid" class="proj-grid"></div>
    </div>


    <!-- BRAND BOARD VIEW -->
    <div id="viewBoard" class="view">
      <div class="home-head" style="margin-bottom:18px">
        <div>
          <h1 id="bbTitle">Brand Board</h1>
          <p id="bbSubtitle">Visão geral da identidade — pronto para gerar materiais.</p>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn btn-ghost" onclick="downloadBrandBoard()">
            <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Exportar Painel
          </button>
          <button class="btn btn-ghost" onclick="nav('editor')">
            <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
            Editar Identidade
          </button>
          <button class="btn btn-primary" onclick="createApplication()">
            <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            Nova Aplicação Rápida
          </button>
        </div>
      </div>

      <div class="block bb-showcase-wrap">
        <div class="block-header">
          <div class="block-title">Visual Guide do Projeto</div>
          <span class="badge accent" id="bbUpdated">Atualizado —</span>
        </div>
        <div class="block-body">
          <div id="bbShowcase" class="bb-showcase"></div>
        </div>
      </div>
    </div>

    <!-- APLICAÇÕES VIEW -->
    <div id="viewApps" class="view">
      <div class="home-head" style="margin-bottom:18px">
        <div>
          <h1>Aplicações</h1>
          <p>Arquivos gerados a partir da identidade do projeto.</p>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn btn-ghost" onclick="nav('board')">Voltar ao Brand Board</button>
          <button class="btn btn-primary" onclick="createApplication()">
            <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            Nova Aplicação Rápida
          </button>
        </div>
      </div>

      <div class="block">
        <div class="block-header">
          <div class="block-title">Lista de aplicações geradas</div>
          <span style="font-size:11px;color:var(--ink3)" id="appsCount"></span>
        </div>
        <div class="block-body">
          <div id="appsList" class="export-grid" style="grid-template-columns:repeat(auto-fill,minmax(320px,1fr))"></div>
        </div>
      </div>
    </div>

    <!-- EDITOR VIEW -->
    <div id="viewEditor" class="view">
      <div class="editor-layout">

        <!-- LEFT -->
        <div class="col-left">

          <!-- Meta -->
          <div class="block">
            <div class="block-header">
              <div class="block-title">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                Identidade
              </div>
              <span class="badge" id="edProjectId">—</span>
            </div>
            <div class="block-body stack">
              <div class="field">
                <label class="field-label">Nome do Projeto</label>
                <input class="inp" id="inpName" placeholder="Ex.: Marca X, App Y...">
              </div>
              <div class="field">
                <label class="field-label">Descrição</label>
                <textarea class="tex inp" id="inpAbout" placeholder="Descrição curta da marca..."></textarea>
              </div>
            </div>
          </div>

          <!-- Logo -->
          <div class="block">
            <div class="block-header">
              <div class="block-title">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                Logo
              </div>
              <span style="font-size:11px;color:var(--ink3)">Fluxo centralizado</span>
            </div>
            <div class="block-body stack">
              <div class="brand-entry-card">
                <div class="field-label" style="margin-bottom:8px">Carregamento de logo e composição</div>
                <p class="brand-entry-copy">Toda importação de imagem da marca agora fica em um único fluxo para evitar retrabalho durante a edição da identidade.</p>
                <div class="brand-entry-inline" id="brandQuickStatus">Sem ativos importados.</div>
                <button class="btn btn-primary" type="button" onclick="openBrandImport()" style="margin-top:6px">
                  <i data-lucide="wand-sparkles" data-size="12"></i>
                  Carregar sua marca
                </button>
                <div class="brand-entry-thumb" id="brandQuickThumb"></div>
              </div>
              <div class="import-stats" style="font-size:11px;line-height:1.45">
                Dica: envie os arquivos no fluxo avançado para ajustar posicionamento, respiro e versões antes de voltar para edição.
              </div>
            </div>
          </div>

          <!-- Colors -->
          <div class="block">
            <div class="block-header">
              <div class="block-title">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="13.5" cy="6.5" r="2.5"/><circle cx="17.5" cy="10.5" r="2.5"/><circle cx="8.5" cy="7.5" r="2.5"/><circle cx="6.5" cy="12.5" r="2.5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></svg>
                Paleta
              </div>
              <button class="add-color-btn" onclick="addColor()">
                <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                Adicionar
              </button>
            </div>
            <div class="block-body">
              <div id="colorBar" class="color-bar-wrap"></div>
              <div id="colorChips" class="color-chips"></div>
            </div>
          </div>

        </div>

        <!-- MID -->
        <div class="col-mid">

          <!-- Fonts -->
          <div class="block">
            <div class="block-header">
              <div class="block-title">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
                Tipografia
              </div>
              <label style="display:flex;align-items:center;gap:6px;font-size:11px;color:var(--ink2);cursor:pointer">
                <input type="checkbox" id="chkRestrict" checked> Restrito
              </label>
            </div>
            <div class="block-body stack">
              <div class="row2">
                <div class="field">
                  <label class="field-label">Primária</label>
                  <select class="sel" id="selPrimary"></select>
                </div>
                <div class="field">
                  <label class="field-label">Secundária</label>
                  <select class="sel" id="selSecondary"></select>
                </div>
              </div>
            </div>
          </div>

          <!-- Type styles -->
          <div class="block">
            <div class="block-header">
              <div class="block-title">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="21" y1="10" x2="3" y2="10"/><line x1="21" y1="6" x2="3" y2="6"/><line x1="21" y1="14" x2="3" y2="14"/><line x1="21" y1="18" x2="11" y2="18"/></svg>
                Hierarquia de Estilos
              </div>
              <span class="badge accent" id="activeStyleBadge" style="display:none"></span>
            </div>
            <div class="block-body">
              <div id="typoList"></div>
              <div id="typoEditor" class="typo-editor">
                <div class="stack" style="margin-top:0">
                  <div class="row3">
                    <div class="field">
                      <label class="field-label">Estilo base</label>
                      <select class="sel" id="edBaseStyle"></select>
                    </div>
                    <div class="field">
                      <label class="field-label">Família</label>
                      <select class="sel" id="edFamily"></select>
                    </div>
                    <div class="field">
                      <label class="field-label">Peso</label>
                      <select class="sel" id="edWeight"></select>
                    </div>
                  </div>
                  <div class="row3">
                    <div class="field">
                      <label class="field-label">Tamanho px</label>
                      <input class="inp" id="edSize" type="number" min="8" max="160">
                    </div>
                    <div class="field">
                      <label class="field-label">Line Height</label>
                      <input class="inp" id="edLine" type="number" step="0.05" min="0.8" max="2.5">
                    </div>
                    <div class="field">
                      <label class="field-label">Letter Sp.</label>
                      <input class="inp" id="edTrack" type="number" step="0.1" min="-5" max="20">
                    </div>
                  </div>
                  <div class="row2">
                    <div class="field">
                      <label class="field-label">Alinhamento</label>
                      <div class="seg-group">
                        <button class="seg-btn" id="bLeft" onclick="applyAlign('left')">≡</button>
                        <button class="seg-btn" id="bCenter" onclick="applyAlign('center')">≣</button>
                        <button class="seg-btn" id="bRight" onclick="applyAlign('right')">≡</button>
                      </div>
                    </div>
                    <div class="field">
                      <label class="field-label">Vertical</label>
                      <div class="seg-group">
                        <button class="seg-btn" id="bVTop" onclick="applyVAlign('top')">↑</button>
                        <button class="seg-btn" id="bVMid" onclick="applyVAlign('middle')">↕</button>
                        <button class="seg-btn" id="bVBot" onclick="applyVAlign('bottom')">↓</button>
                      </div>
                    </div>
                  </div>
                  <div class="chip-row">
                    <button class="chip-btn" id="btnUpper" onclick="toggleStyle('upper')">⇧ UPPERCASE</button>
                    <button class="chip-btn" id="btnItalic" onclick="toggleStyle('italic')">/ Itálico</button>
                  </div>
                  <div style="display:flex;gap:8px;padding-top:4px">
                    <button class="btn btn-ghost" onclick="closeStyleEditor()">Fechar</button>
                    <button class="btn btn-primary" onclick="saveStyle()">Salvar Estilo</button>
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div>

        <!-- PREVIEW -->
        <div class="col-preview">
          <div class="block" style="position:sticky;top:76px;">
            <div class="block-header">
              <div class="block-title">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                Preview ao Vivo
              </div>
            </div>
            <div id="livePreview" class="preview-scroll fade-edge"></div>
          </div>
        </div>

      </div>
    </div>

    <!-- BRAND IMPORT VIEW -->
    <div id="viewBrandImport" class="view">
      <div class="home-head" style="margin-bottom:14px">
        <div>
          <h1>Carregar sua marca</h1>
          <p>Faça upload dos elementos da identidade, ajuste composição e finalize antes de voltar para a edição.</p>
        </div>
        <button class="btn btn-ghost" onclick="nav('editor')">Voltar</button>
      </div>
      <div class="brand-import-shell">
        <div class="brand-import-main">
          <div class="brand-import-controls block">
          <div class="block-header"><div class="block-title">Identidade da Marca</div></div>
          <div class="block-body stack">
            <div class="field">
              <label class="field-label">Nome base (para arquivos)</label>
              <input class="inp" id="inpBrandBaseName" placeholder="minha-marca" disabled>
            </div>
            <div class="field-label">Uploads da marca</div>
            <div class="upload-row">
              <button class="btn btn-ghost" onclick="triggerLogo('sq')" style="justify-content:center">Símbolo / Ícone</button>
              <button class="btn btn-ghost mini" onclick="clearLogo('sq')" style="justify-content:center">Limpar</button>
            </div>
            <div class="upload-row">
              <button class="btn btn-ghost" onclick="triggerLogo('wd')" style="justify-content:center">Logotipo - Parte 1</button>
              <button class="btn btn-ghost mini" onclick="clearLogo('wd')" style="justify-content:center">Limpar</button>
            </div>
            <div id="extraUploadList" class="stack" style="gap:8px"></div>
            <button class="btn btn-ghost" onclick="addExtraLogoSlot()" style="justify-content:center">+ Adicionar logo / texto</button>
            <div class="field"><label class="field-label">Altura X (%)</label><input id="inpXHeight" class="inp" type="range" min="20" max="90" step="1" oninput="updateBrandImportSetting('xHeight',this.value)"></div>
            <div class="field"><label class="field-label">Área de respiro (%)</label><input id="inpSafeMargin" class="inp" type="range" min="0" max="40" step="1" oninput="updateBrandImportSetting('safeMargin',this.value)"></div>
            <button class="btn btn-primary" onclick="applyBrandImportToSlots()" style="justify-content:center">Aplicar ajustes da marca</button>
            <div id="brandImportStats" class="import-stats">Sem ativos importados.</div>
          </div>
        </div>
        <div class="brand-import-preview block">
          <div class="block-header"><div class="block-title">Composição Final</div></div>
          <div class="block-body stack">
            <div class="brand-preview-grid">
              <div class="brand-preview-panel">
                <div class="field-label" style="margin-bottom:6px">Logo quadrado</div>
                <div class="brand-preview-slot" id="advSlotSq"></div>
                <div class="row2" style="margin-top:8px">
                  <input class="inp" id="advSqX" type="number" placeholder="X" oninput="updateBrandPlacement('sq','x',this.value)">
                  <input class="inp" id="advSqY" type="number" placeholder="Y" oninput="updateBrandPlacement('sq','y',this.value)">
                </div>
                <input class="inp" id="advSqScale" type="range" min="20" max="220" value="100" oninput="updateBrandPlacement('sq','scale',this.value)">
              </div>
              <div class="brand-preview-panel">
                <div class="field-label" style="margin-bottom:6px">Logo horizontal</div>
                <div class="brand-preview-slot" id="advSlotWd"></div>
                <div class="row2" style="margin-top:8px">
                  <input class="inp" id="advWdX" type="number" placeholder="X" oninput="updateBrandPlacement('wd','x',this.value)">
                  <input class="inp" id="advWdY" type="number" placeholder="Y" oninput="updateBrandPlacement('wd','y',this.value)">
                </div>
                <input class="inp" id="advWdScale" type="range" min="20" max="220" value="100" oninput="updateBrandPlacement('wd','scale',this.value)">
              </div>
            </div>
            <div>
              <div class="field-label" style="margin-bottom:6px">Elementos adicionais da marca</div>
              <div id="advExtraPreview" class="brand-extra-grid"></div>
            </div>
            <div>
              <div class="field-label" style="margin-bottom:6px">Painel combinado</div>
              <div class="brand-composite" id="brandCompositePreview"></div>
            </div>
          </div>
        </div>
        </div>
        <div class="brand-import-side">
          <div class="block">
            <div class="block-header"><div class="block-title">Layout & Composição</div></div>
            <div class="block-body stack">
              <div class="field"><label class="field-label">Estrutura da marca</label><select class="sel" disabled><option>Horizontal (símbolo + logotipo)</option></select></div>
              <div class="field"><label class="field-label">Layout do logotipo</label><select class="sel" disabled><option>Stack (1 sobre 2)</option></select></div>
              <div class="field"><label class="field-label">Grid de construção</label><select class="sel" disabled><option>Oculto</option></select></div>
              <div class="field"><label class="field-label">Área de proteção</label><select class="sel" disabled><option>Visível</option></select></div>
              <div class="import-stats">Os ajustes finos de layout podem ser ligados nas próximas versões. Por enquanto, use altura X, respiro e posição manual.</div>
            </div>
          </div>
          <div class="block">
            <div class="block-header"><div class="block-title">Paleta & Exportar</div></div>
            <div class="block-body stack">
              <div id="brandImportPalette" class="stack" style="gap:8px"></div>
              <div class="row2">
                <button class="btn btn-ghost" onclick="nav('editor')" style="justify-content:center">Editar cores</button>
                <button class="btn btn-primary" onclick="nav('export')" style="justify-content:center">Ir para exportar</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- EXPORT VIEW -->
    <div id="viewExport" class="view">
      <div class="home-head">
        <div>
          <h1>Exportar</h1>
          <p>Gerencie pastas, subpastas e arquivos gerados da marca e das aplicações.</p>
        </div>
      </div>
      <div id="exportManager"></div>
      <div id="exportGrid" class="export-grid"></div>
    </div>

  </div><!-- /main -->
</div><!-- /shell -->


<input id="fileLogoSq" type="file" accept=".svg,image/*" style="display:none">
<input id="fileLogoWd" type="file" accept=".svg,image/*" style="display:none">
<input id="fileLogoExtra" type="file" accept=".svg,image/*" style="display:none">


<!-- =========================================================
     APP EDITOR (FULLSCREEN) — Embedded Advanced Editor
========================================================= -->
<div id="viewAppEditor" class="view">
  <div class="appedit-shell">
    <!-- EDITOR BODY: apenas o iframe ocupa tudo -->
    <div class="appedit-body">
      <div class="ge-iframeWrap">
        <iframe id="geEditorFrame" title="Goblin Editor"
          sandbox="allow-scripts allow-same-origin allow-downloads"
          referrerpolicy="no-referrer"
          style="width:100%;height:100%;border:0;border-radius:18px;overflow:hidden;background:transparent"></iframe>
      </div>
    </div>
  </div>
</div>

<!-- IDs fantasmas para que o código JS não quebre ao buscar esses elementos -->
<div style="display:none" aria-hidden="true">
  <span id="selTag"></span><span id="selType"></span>
  <input id="fillHex"><input id="fillColor"><input id="posX"><input id="posY">
  <input id="sizeW"><input id="sizeH"><input id="radius"><input id="fontSize">
  <input id="textValue"><select id="fontWeight"></select><select id="stylePick"></select>
  <div id="paletteRow"></div><div id="layerList"></div><span id="layerCount"></span>
  <div id="sizeTitle"></div><div id="sizeWRow"></div><div id="sizeHRow"></div>
  <div id="radiusRow"></div><div id="textStyleRow"></div>
  <div id="appCanvasHost"></div>
</div>

<template id="geEditorTemplate">
&lt;!doctype html&gt;
&lt;html lang="pt-BR"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"/&gt;
&lt;meta name="viewport" content="width=device-width,initial-scale=1"/&gt;
&lt;title&gt;Studio&lt;/title&gt;
&lt;script src="https://unpkg.com/fabric@5.3.0/dist/fabric.min.js"&gt;&lt;/script&gt;
&lt;link rel="preconnect" href="https://fonts.googleapis.com"&gt;
&lt;link rel="preconnect" href="https://fonts.gstatic.com" crossorigin&gt;
&lt;link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&amp;family=Syne:wght@400;500;600;700;800&amp;family=Outfit:wght@300;400;500;600;700;800;900&amp;family=Sora:wght@300;400;600;700;800&amp;family=DM+Sans:wght@300;400;500;600;700&amp;family=Nunito:wght@300;400;600;700;800&amp;family=Poppins:wght@300;400;600;700;800&amp;family=Montserrat:wght@300;400;600;700;800&amp;family=IBM+Plex+Sans:wght@300;400;600;700&amp;family=Raleway:wght@300;400;600;700;800&amp;family=Manrope:wght@300;400;600;700;800&amp;family=Inter:wght@300;400;600;800&amp;family=Roboto:wght@300;400;700&amp;display=swap" rel="stylesheet"&gt;
&lt;style&gt;
:root {
  --bg:       #0e0e11;
  --surface:  #16161a;
  --panel:    #1e1e24;
  --border:   rgba(255,255,255,.07);
  --border2:  rgba(255,255,255,.12);
  --ink:      #f0eff4;
  --ink2:     rgba(240,239,244,.65);
  --ink3:     rgba(240,239,244,.32);
  --accent:   #7f5af0;
  --accent-d: #6848d2;
  --danger:   #e85d5d;
  --good:     #2cb67d;
  --mono:     'DM Mono', monospace;
  --sans:     'Syne', sans-serif;
  --r:        10px;
  --r-lg:     16px;
  --panel-w:  224px;
  --topbar-h: 48px;
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;overflow:hidden;background:var(--bg)}
body{font-family:'Outfit', ui-sans-serif, system-ui, sans-serif;font-size:13px;color:var(--ink)}

button{font-family:inherit;cursor:pointer;border:none;outline:none;user-select:none}
input,select{font-family:'JetBrains Mono', ui-monospace, monospace;color:var(--ink);background:var(--bg);border:1px solid var(--border2);outline:none;font-size:12px}
input:focus,select:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(127,90,240,.15)}

/* ─── LAYOUT ──────────────────────────────────────────── */
.app{
  display:grid;
  grid-template-rows: 30px var(--topbar-h) 1fr;
  grid-template-columns: var(--panel-w) 1fr var(--panel-w);
  height:100%;
}

.menu-bar{
  grid-column:1 / -1;
  display:flex;
  align-items:center;
  gap:10px;
  padding:0 14px;
  border-bottom:1px solid var(--border);
}
.menu-bar{background:#202026;font-size:12px}
.menu-item{color:var(--ink2);padding:4px 8px;border-radius:6px}
.menu-item:hover{background:rgba(255,255,255,.08);color:var(--ink)}
.menu-item.active{background:rgba(127,90,240,.18);color:#fff}
.menu-spacer{margin-left:auto}
.menu-dd{position:relative}
.menu-item-btn{border:none;cursor:pointer;background:transparent;color:var(--ink2);font:inherit;line-height:1;display:inline-flex;align-items:center}
.menu-item-btn:hover{background:rgba(255,255,255,.08);color:var(--ink)}
.menu-item-btn.active{background:rgba(127,90,240,.18);color:#fff}
.menu-dd-panel{
  display:none;position:absolute;top:calc(100% + 8px);left:0;z-index:50;
  width:320px;padding:12px;border-radius:12px;background:var(--panel);
  border:1px solid var(--border2);box-shadow:0 24px 48px rgba(0,0,0,.45);
}
.menu-dd.open .menu-dd-panel{display:block}
.menu-dd-panel.compact{width:260px;padding:8px}
.menu-cmd{height:30px;display:flex;align-items:center;justify-content:space-between;gap:12px;padding:0 8px;border-radius:7px;color:var(--ink2);font-family:var(--mono);font-size:11px;cursor:pointer}
.menu-cmd:hover{background:rgba(255,255,255,.08);color:#fff}
.menu-cmd .k{opacity:.75;font-size:10px}
.menu-cmd-sep{height:1px;background:var(--border);margin:6px 4px}

.ctx-pill{height:26px;padding:0 10px;border-radius:8px;border:1px solid var(--border2);display:inline-flex;align-items:center;color:var(--ink2)}
.ctx-pill strong{color:var(--ink);font-weight:600}

/* ─── TOPBAR ──────────────────────────────────────────── */
.topbar{
  grid-column: 1 / -1;
  display:flex;align-items:center;gap:0;
  background:var(--surface);
  border-bottom:1px solid var(--border);
  position:relative;
  z-index:10;
}
.topbar-brand{
  display:flex;align-items:center;gap:10px;
  padding:0 20px;
  flex:1;
  min-width:0;
  border-right:1px solid var(--border);
  height:100%;
  flex-shrink:0;
}
.topbar-name-input{
  flex:1;
  min-width:0;
  height:30px;
  font-size:11px;
  border-radius:8px;
  background:rgba(255,255,255,.03);
}
.brand-dot{
  width:20px;height:20px;border-radius:6px;
  background:var(--accent);
  box-shadow:0 0 12px rgba(127,90,240,.45);
  flex-shrink:0;
}
.brand-name{
  font-size:13px;font-weight:700;letter-spacing:.04em;
  color:var(--ink);font-family:'Outfit', ui-sans-serif, system-ui, sans-serif;
}
.topbar-status{
  flex:1;display:flex;align-items:center;justify-content:center;
  gap:6px;
  font-family:'JetBrains Mono', ui-monospace, monospace;font-size:11px;color:var(--ink3);
  letter-spacing:.04em;
}
.status-dot{
  width:6px;height:6px;border-radius:50%;
  background:var(--accent);
  animation:pulse 2s ease-in-out infinite;
}
@keyframes pulse{0%,100%{opacity:1;box-shadow:0 0 0 0 rgba(127,90,240,.35)}50%{opacity:.7;box-shadow:0 0 0 4px rgba(127,90,240,0)}}
.topbar-actions{
  display:flex;align-items:center;gap:6px;
  padding:0 12px;
  border-left:1px solid var(--border);
  height:100%;
  flex-shrink:0;
}

/* ─── TOOLBAR BUTTONS ─────────────────────────────────── */
.tbtn{
  height:30px;padding:0 10px;border-radius:var(--r);
  background:transparent;color:var(--ink2);
  font-family:'JetBrains Mono', ui-monospace, monospace;font-size:11px;font-weight:500;
  letter-spacing:.03em;
  border:1px solid transparent;
  transition:all .12s ease;display:inline-flex;align-items:center;gap:5px;
}
.tbtn:hover{background:rgba(255,255,255,.06);color:var(--ink);border-color:var(--border2)}
.tbtn.accent{
  background:var(--accent);color:#fff;font-weight:700;
  border-color:transparent;
}
.tbtn.accent:hover{background:#9370f5;box-shadow:0 0 12px rgba(127,90,240,.35)}
.tbtn.danger{color:var(--danger)}
.tbtn.danger:hover{background:rgba(255,64,96,.1);border-color:rgba(255,64,96,.25)}
.tbtn.active{background:rgba(127,90,240,.12);color:var(--accent);border-color:rgba(127,90,240,.26)}
.tbtn svg{flex-shrink:0}

/* ─── PANELS ──────────────────────────────────────────── */
.panel{
  background:var(--panel);
  border-right:1px solid var(--border);
  display:flex;flex-direction:column;
  overflow:hidden;
  min-height:0;
}
.panel.right{border-right:none;border-left:1px solid var(--border)}
.panel-head{
  padding:14px 16px 10px;
  border-bottom:1px solid var(--border);
  flex-shrink:0;
}
.panel-label{
  font-size:9px;font-weight:700;letter-spacing:.12em;
  text-transform:uppercase;color:var(--ink3);
  font-family:'JetBrains Mono', ui-monospace, monospace;
  margin-bottom:10px;
}
.panel-body{flex:1;overflow-y:auto;overflow-x:hidden;padding:10px 12px 16px}
.panel-body::-webkit-scrollbar{width:3px}
.panel-body::-webkit-scrollbar-thumb{background:var(--border2);border-radius:2px}
.panel-section{margin-bottom:16px}
.panel-section-label{
  font-size:9px;letter-spacing:.1em;text-transform:uppercase;
  color:var(--ink3);font-family:'JetBrains Mono', ui-monospace, monospace;
  margin-bottom:8px;font-weight:600;
}

/* ─── TOOLBAR (floating) ─────────────────────────────── */
.floating-toolbar-wrap{position:absolute;left:50%;bottom:30px;transform:translateX(-50%);z-index:12;display:inline-flex;flex-direction:column;align-items:center;gap:8px;pointer-events:auto;width:max-content;max-width:calc(100% - 28px)}
.floating-toolbar-row{display:flex;align-items:center;white-space:nowrap;width:max-content;max-width:calc(100vw - 48px);background:linear-gradient(180deg, rgba(34,34,42,.96), rgba(22,22,28,.96));border:1px solid rgba(255,255,255,.09);border-radius:16px;box-shadow:0 10px 24px rgba(0,0,0,.34), inset 0 1px 0 rgba(255,255,255,.06);overflow:hidden;backdrop-filter:blur(10px)}
.float-tool-btn{height:40px;padding:0 13px;border-right:1px solid rgba(255,255,255,.08);background:transparent;color:rgba(240,239,244,.78);font-family:var(--mono);font-size:12px;font-weight:600;display:flex;align-items:center;gap:6px;flex:0 0 auto}
.float-tool-btn:last-child{border-right:none}
.float-tool-btn:hover{background:rgba(255,255,255,.06);color:#fff}
.float-tool-btn.active{background:rgba(127,90,240,.24);color:#fff;box-shadow:inset 0 0 0 1px rgba(127,90,240,.3)}
.float-tool-btn.icon{width:40px;justify-content:center;padding:0;font-size:14px}
.float-tool-sep{width:1px;height:20px;background:rgba(255,255,255,.12)}
.top-tools{display:none}
.floating-toolbar-wrap.show-bezier-submenu .top-tools{display:flex}
.top-tools{position:absolute;left:50%;bottom:calc(100% + 8px);transform:translateX(-50%)}
.fixed-tools{position:relative}
.tool-submenu{position:absolute;bottom:calc(100% + 8px);left:0;display:none;flex-direction:column;gap:4px;min-width:168px;padding:6px;background:rgba(24,24,29,.98);border:1px solid var(--border2);border-radius:10px;box-shadow:0 18px 36px rgba(0,0,0,.45)}
.tool-submenu.open{display:flex}
.tool-submenu-btn{height:30px;border-radius:7px;border:1px solid transparent;background:transparent;color:var(--ink2);font-family:var(--mono);font-size:11px;display:flex;align-items:center;justify-content:space-between;padding:0 8px}
.tool-submenu-btn:hover{background:rgba(255,255,255,.08);color:#fff}
.tool-submenu-btn.active{background:rgba(127,90,240,.18);border-color:rgba(127,90,240,.32);color:#fff}
.ctx-pop{position:fixed;display:none;min-width:220px;background:rgba(24,24,29,.98);border:1px solid var(--border2);border-radius:12px;box-shadow:0 18px 36px rgba(0,0,0,.45);padding:6px;z-index:80}
.ctx-pop.open{display:block}
.ctx-pop-item{height:34px;border-radius:8px;padding:0 10px;display:flex;align-items:center;justify-content:space-between;color:var(--ink2);font-size:12px;font-family:var(--mono)}
.ctx-pop-item:hover{background:rgba(255,255,255,.07);color:#fff}
.ctx-pop-sep{height:1px;background:var(--border);margin:6px 2px}

.text-float-panel{position:absolute;left:24px;bottom:24px;z-index:13;width:300px;background:rgba(24,24,29,.96);border:1px solid var(--border2);border-radius:14px;box-shadow:0 20px 44px rgba(0,0,0,.45);display:none;overflow:hidden}
.text-float-panel.open{display:block}
.text-float-head{display:flex;align-items:center;gap:8px;padding:10px 12px;border-bottom:1px solid var(--border)}
.text-float-tabs{display:flex;gap:4px}
.text-float-tab{height:28px;padding:0 10px;border-radius:8px;border:1px solid transparent;background:transparent;color:var(--ink2);font-size:11px;font-family:var(--mono)}
.text-float-tab.active{background:rgba(127,90,240,.18);color:#fff;border-color:rgba(127,90,240,.35)}
.text-float-close{margin-left:auto;width:28px;height:28px;border-radius:8px;border:1px solid var(--border2);background:transparent;color:var(--ink2)}
.text-float-body{padding:10px 12px;display:grid;gap:8px}
.text-float-grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.text-float-panel [data-pane]{display:none}
.text-float-panel [data-pane].active{display:grid;gap:8px}

/* ─── DOC INPUTS ──────────────────────────────────────── */
.field-row{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:8px}
.field-row.one{grid-template-columns:1fr}
.field-item{display:flex;flex-direction:column;gap:4px}
.field-label{font-size:9px;letter-spacing:.08em;text-transform:uppercase;color:var(--ink3);font-family:var(--mono)}
.field-input{
  height:32px;padding:0 9px;border-radius:8px;width:100%;
  background:var(--surface);border:1px solid var(--border2);
  color:var(--ink);font-family:'JetBrains Mono', ui-monospace, monospace;font-size:12px;
}
.field-input:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(127,90,240,.14)}
input[type="color"].field-input{padding:2px 4px;cursor:pointer}

/* ─── SEPARATOR ───────────────────────────────────────── */
.sep{height:1px;background:var(--border);margin:12px -12px}

/* ─── LAYERS ──────────────────────────────────────────── */
#layersList{padding-right:2px;scrollbar-width:thin;scrollbar-color:rgba(127,90,240,.7) rgba(255,255,255,.06)}
#layersList::-webkit-scrollbar{width:9px}
#layersList::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px}
#layersList::-webkit-scrollbar-thumb{background:linear-gradient(180deg, rgba(127,90,240,.9), rgba(76,129,255,.9));border-radius:999px;border:2px solid rgba(22,22,28,.95)}
#layersList::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg, rgba(151,116,255,.95), rgba(104,152,255,.95))}
.layer-item{
  display:grid;grid-template-columns:10px 1fr auto;gap:10px;align-items:center;
  padding:9px 10px;border-radius:10px;border:1px solid transparent;
  cursor:pointer;transition:all .14s ease;margin-bottom:6px;
  background:rgba(255,255,255,.015);
}
.layer-main{display:flex;align-items:center;gap:8px;min-width:0}
.layer-item:hover{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.1)}
.layer-item.active{background:rgba(127,90,240,.14);border-color:rgba(127,90,240,.45)}
.layer-item.drag-over{border-color:rgba(127,90,240,.78);background:rgba(127,90,240,.2)}
.layer-item.is-hidden{opacity:.58}
.layer-marker{width:8px;height:8px;border-radius:999px;background:rgba(255,255,255,.28);box-shadow:0 0 0 1px rgba(255,255,255,.15)}
.layer-item.active .layer-marker{background:var(--accent);box-shadow:0 0 0 2px rgba(127,90,240,.22)}
.layer-name{font-size:12px;font-family:'JetBrains Mono', ui-monospace, monospace;color:var(--ink);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.layer-item.is-hidden .layer-name{text-decoration:line-through;color:var(--ink3)}
.layer-meta{font-size:11px;color:var(--ink3);font-family:var(--mono)}
.layer-row-meta{display:flex;align-items:center;gap:8px;margin-left:auto}
.layer-vis-btn{width:20px;height:20px;border-radius:6px;border:1px solid var(--border2);background:rgba(255,255,255,.03);display:flex;align-items:center;justify-content:center;color:var(--ink2)}
.layer-vis-btn:hover{border-color:rgba(127,90,240,.55);color:#fff;background:rgba(127,90,240,.14)}
.layer-empty{text-align:center;padding:24px 0;font-size:11px;color:var(--ink3);font-family:'JetBrains Mono', ui-monospace, monospace}
.artboard-list{display:grid;gap:6px;max-height:170px;overflow:auto;padding-right:2px}
.artboard-item{display:flex;align-items:center;gap:8px;border:1px solid var(--border2);border-radius:8px;padding:6px 8px;background:rgba(255,255,255,.02);cursor:pointer}
.artboard-item.active{border-color:rgba(127,90,240,.45);background:rgba(127,90,240,.12)}
.artboard-name{flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-family:var(--mono);font-size:11px}
.artboard-size{font-size:10px;color:var(--ink3);font-family:var(--mono)}
.lib-item{
  display:flex;align-items:center;gap:8px;
  padding:7px 9px;border-radius:8px;
  border:1px solid transparent;
  cursor:pointer;transition:all .1s ease;
  margin-bottom:3px;
}
.lib-item:hover{background:rgba(255,255,255,.04)}
.lib-item[draggable="true"]{cursor:grab}
.lib-item:active{cursor:grabbing}
.lib-preview{width:42px;height:30px;border-radius:7px;border:1px solid var(--border2);background:linear-gradient(135deg, rgba(255,255,255,.10), rgba(255,255,255,.02));background-size:cover;background-position:center;flex-shrink:0}
.lib-icon{
  width:22px;height:22px;border-radius:5px;background:var(--surface);
  display:flex;align-items:center;justify-content:center;flex-shrink:0;
  color:var(--ink3);font-size:11px
}
.lib-name{flex:1;font-size:11px;font-family:'JetBrains Mono', ui-monospace, monospace;color:var(--ink2);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.lib-meta{font-size:10px;color:var(--ink3);font-family:'JetBrains Mono', ui-monospace, monospace}

/* ─── PROPS PANEL ─────────────────────────────────────── */
.prop-row{margin-bottom:8px}
.prop-grid2{display:grid;grid-template-columns:1fr 1fr;gap:6px}
.prop-grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:5px}

/* Segmented control */
.seg{
  display:flex;background:var(--surface);
  border:1px solid var(--border2);border-radius:8px;overflow:hidden;
}
.seg-opt{
  flex:1;height:30px;
  display:flex;align-items:center;justify-content:center;
  font-size:11px;font-family:'JetBrains Mono', ui-monospace, monospace;color:var(--ink3);
  cursor:pointer;transition:all .1s ease;
  background:transparent;
}
.seg-opt:hover{color:var(--ink)}
.seg-opt.on{background:var(--accent);color:#fff;font-weight:700}

/* Palette swatches */
.swatch-grid{display:flex;flex-wrap:wrap;gap:5px;margin-top:6px}
.swatch{
  width:22px;height:22px;border-radius:6px;
  border:1px solid rgba(255,255,255,.12);cursor:pointer;
  transition:transform .1s ease,box-shadow .1s ease;
}
.swatch:hover{transform:scale(1.15);box-shadow:0 0 0 2px var(--accent)}

/* ─── CANVAS AREA ─────────────────────────────────────── */
.canvas-area{
  position:relative;overflow:hidden;
  background:var(--desk-bg,
    radial-gradient(ellipse 60% 50% at 25% 20%, rgba(127,90,240,.12), transparent),
    radial-gradient(ellipse 50% 60% at 75% 80%, rgba(44,182,125,.08), transparent),
    var(--bg)
  );
}
/* dot grid */
.canvas-area::before{
  content:'';position:absolute;inset:0;
  background-image:radial-gradient(circle, var(--desk-dot, rgba(255,255,255,.08)) 1px, transparent 1px);
  background-size:28px 28px;
  pointer-events:none;z-index:0;
}
#fabricCanvas{position:absolute;inset:0;z-index:1}
#fabricCanvas canvas{display:block}
.artboard-plus-ui{position:absolute;inset:0;pointer-events:none;z-index:6;display:none}
.ab-plus{
  position:absolute;width:28px;height:28px;border-radius:999px;
  border:1px solid var(--border2);background:rgba(14,14,17,.9);color:#fff;
  display:grid;place-items:center;font-size:18px;line-height:1;
  box-shadow:0 8px 22px rgba(0,0,0,.35);pointer-events:auto;
}
.ab-plus:hover{background:var(--accent);border-color:rgba(255,255,255,.35)}

/* ─── MODAL ───────────────────────────────────────────── */
.modal-bg{
  display:none;position:fixed;inset:0;
  background:rgba(0,0,0,.7);backdrop-filter:blur(6px);
  z-index:100;align-items:center;justify-content:center;
}
.modal-bg.open{display:flex}
.modal-box{
  background:var(--panel);border:1px solid var(--border2);
  border-radius:var(--r-lg);padding:24px;
  min-width:360px;max-width:520px;width:90%;
  max-height:80vh;display:flex;flex-direction:column;
  box-shadow:0 40px 80px rgba(0,0,0,.7);
}
.modal-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
.modal-title{font-size:15px;font-weight:700}
.modal-body{flex:1;overflow:auto}
textarea.modal-textarea{
  width:100%;min-height:200px;resize:vertical;
  background:var(--surface);border:1px solid var(--border2);
  border-radius:var(--r);padding:12px;color:var(--ink);
  font-family:'JetBrains Mono', ui-monospace, monospace;font-size:11px;line-height:1.6;
}

/* ─── SHORTCUTS POPUP ─────────────────────────────────── */
.shortcuts-grid{display:grid;grid-template-columns:auto 1fr;gap:6px 14px;align-items:center}

.smart-two-overlay{position:absolute;inset:0;pointer-events:none;z-index:15}
.smart-swap-btn,.smart-gap-handle{position:absolute;display:none;pointer-events:auto}
.smart-swap-btn{
  width:24px;height:24px;border-radius:999px;border:1px solid rgba(255,77,141,.9);
  background:rgba(23,19,35,.95);color:#ff6aa3;font-size:13px;font-family:var(--mono);cursor:pointer
}
.smart-swap-btn:hover{background:rgba(41,31,60,.95)}
.smart-gap-handle{
  border:1px solid rgba(255,77,141,.9);border-radius:999px;background:rgba(255,77,141,.15);cursor:ew-resize
}
.smart-two-overlay.show-swap .smart-swap-btn{display:block}
.smart-two-overlay.show-gap .smart-gap-handle{display:block}
.is-dragging-gap{cursor:ew-resize!important}

.sc-key{font-family:'JetBrains Mono', ui-monospace, monospace;font-size:11px;
  background:rgba(255,255,255,.07);border:1px solid var(--border2);
  padding:3px 8px;border-radius:6px;color:var(--accent);white-space:nowrap;text-align:center}
.sc-desc{font-size:11px;color:var(--ink2);font-family:var(--mono)}
.panel-tabs{display:flex;gap:4px;padding:4px;background:#19191e;border:1px solid var(--border);border-radius:10px;margin-bottom:10px}
.panel-tab{flex:1;text-align:center;padding:6px 4px;font-size:11px;color:var(--ink2);border-radius:7px}
.panel-tab.active{background:#2d2d35;color:var(--ink);font-weight:600}
.rp-row{display:flex;gap:6px;align-items:center;margin-bottom:8px}
.rp-icon-btn{height:30px;min-width:30px;padding:0 8px;border-radius:8px;border:1px solid var(--border2);background:var(--surface);color:var(--ink2);font-family:var(--mono);font-size:11px;display:inline-flex;align-items:center;justify-content:center}
.rp-icon-btn:hover{color:var(--ink);border-color:rgba(255,255,255,.24)}
.rp-icon-btn.active{background:rgba(127,90,240,.16);border-color:rgba(127,90,240,.35);color:#fff}
.rp-grow{flex:1}
.rp-stroke-range{width:100%;accent-color:var(--accent)}
.rp-chip{height:24px;padding:0 8px;border-radius:999px;border:1px solid var(--border2);display:inline-flex;align-items:center;font-size:10px;color:var(--ink2);background:rgba(255,255,255,.02)}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="app"&gt;

  &lt;div class="menu-bar"&gt;
    &lt;div class="menu-dd" id="menuFileRoot"&gt;
      &lt;button class="menu-item menu-item-btn active" id="btnMenuFile"&gt;Arquivo&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuFilePanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuEditRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuEdit"&gt;Editar&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuEditPanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuSelectRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuSelect"&gt;Seleção&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuSelectPanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuCreateRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuCreate"&gt;Criar&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuCreatePanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuTransformRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuTransform"&gt;Transformar&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuTransformPanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuAppearanceRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuAppearance"&gt;Aparência&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuAppearancePanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuOrganizeRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuOrganize"&gt;Organizar&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuOrganizePanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuBooleanRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuBoolean"&gt;Boolean&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuBooleanPanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuTextRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuText"&gt;Texto&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuTextPanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuViewRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuView"&gt;Exibir&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuViewPanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="menu-dd" id="menuAdvancedRoot"&gt;
      &lt;button class="menu-item menu-item-btn" id="btnMenuAdvanced"&gt;Avançado&lt;/button&gt;
      &lt;div class="menu-dd-panel compact" id="menuAdvancedPanel"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;span class="menu-spacer"&gt;&lt;/span&gt;
  &lt;/div&gt;

  &lt;header class="topbar"&gt;
    &lt;div class="topbar-brand"&gt;
      &lt;div class="brand-dot"&gt;&lt;/div&gt;
      &lt;input id="projectNameInline" class="field-input topbar-name-input" type="text" value="Aplicação" /&gt;
    &lt;/div&gt;
    &lt;div class="topbar-status"&gt;
      &lt;button class="tbtn" id="btnUndo" title="Undo (Ctrl+Z)"&gt;
        &lt;svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"&gt;&lt;polyline points="1 4 1 10 7 10"/&gt;&lt;path d="M3.51 15a9 9 0 1 0 .49-4.5"/&gt;&lt;/svg&gt;
      &lt;/button&gt;
      &lt;button class="tbtn" id="btnRedo" title="Redo (Ctrl+Shift+Z)"&gt;
        &lt;svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"&gt;&lt;polyline points="23 4 23 10 17 10"/&gt;&lt;path d="M20.49 15a9 9 0 1 1-.49-4.5"/&gt;&lt;/svg&gt;
      &lt;/button&gt;
      &lt;span id="statusText"&gt;Pronto&lt;/span&gt; &lt;span id="zoomTopLabel" style="color:var(--ink2)"&gt;ZOOM 100%&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="topbar-actions"&gt;
      &lt;button class="tbtn" id="btnDelete" title="Apagar seleção (Del)"&gt;
        &lt;svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"&gt;&lt;polyline points="3 6 5 6 21 6"/&gt;&lt;path d="M19 6l-1 14H6L5 6"/&gt;&lt;path d="M10 11v6M14 11v6"/&gt;&lt;/svg&gt;
      &lt;/button&gt;
      &lt;button class="tbtn" id="btnDuplicate" title="Duplicar"&gt;
        &lt;svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"&gt;&lt;rect x="9" y="9" width="13" height="13" rx="2"/&gt;&lt;path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/&gt;&lt;/svg&gt;
      &lt;/button&gt;
      &lt;button class="tbtn" id="btnCloseEditor" title="Fechar editor"&gt;✕&lt;/button&gt;
    &lt;/div&gt;
  &lt;/header&gt;


  &lt;!-- ═══ LEFT PANEL ════════════════════════════════════ --&gt;
  &lt;aside class="panel"&gt;
    &lt;div class="panel-body"&gt;


      &lt;div class="panel-section" style="max-height:220px;display:flex;flex-direction:column"&gt;
        &lt;div class="panel-section-label" style="display:flex;justify-content:space-between;align-items:center;gap:8px"&gt;
          &lt;span&gt;Artboards&lt;/span&gt;
          &lt;div style=&quot;display:flex;align-items:center;gap:8px&quot;&gt;
            &lt;button class=&quot;tbtn&quot; id=&quot;btnNewArtboard&quot; title=&quot;Criar novo artboard&quot; style=&quot;height:24px;padding:0 8px&quot;&gt;Novo&lt;/button&gt;
            &lt;span id=&quot;artboardCount&quot; style=&quot;color:var(--ink3)&quot;&gt;0&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id=&quot;artboardList&quot; class=&quot;artboard-list&quot; style=&quot;flex:1;max-height:none&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;div class="panel-section" id="vectorNodePanel" style="display:none"&gt;
        &lt;div class="panel-section-label"&gt;Vetor · Estilizar nó&lt;/div&gt;
        &lt;div class="layer-empty" id="vectorNodeHint"&gt;Selecione um nó.&lt;/div&gt;
        &lt;div id="vectorNodeControls" style="display:none"&gt;
          &lt;div class="field-label" style="margin-bottom:6px"&gt;Tipo do nó&lt;/div&gt;
          &lt;div style="display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px"&gt;
            &lt;button class="tbtn" id="btnNodeCorner" style="justify-content:center;height:30px"&gt;Canto&lt;/button&gt;
            &lt;button class="tbtn" id="btnNodeSmooth" style="justify-content:center;height:30px"&gt;Suave&lt;/button&gt;
            &lt;button class="tbtn" id="btnNodeMirrored" style="justify-content:center;height:30px"&gt;Espelhado&lt;/button&gt;
          &lt;/div&gt;
          &lt;button class="tbtn" id="btnNodeBreak" style="width:100%;justify-content:center;height:30px;margin-top:8px"&gt;Quebrar alças&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="panel-section" style="max-height:360px;display:flex;flex-direction:column"&gt;
        &lt;div class="panel-section-label" style="display:flex;justify-content:space-between" title="Arraste para ordenar • duplo clique para renomear"&gt;
          &lt;span title="Arraste para ordenar • duplo clique para renomear"&gt;Camadas&lt;/span&gt;
          &lt;span id="layerCount" style="color:var(--ink3)" title="Arraste para ordenar • duplo clique para renomear"&gt;0&lt;/span&gt;
        &lt;/div&gt;
        &lt;div id="layersList" style="flex:1;overflow-y:auto;overflow-x:hidden"&gt;&lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;!-- Library --&gt;
      &lt;div class="panel-section"&gt;
        &lt;div class="panel-section-label" style="display:flex;justify-content:space-between"&gt;
          Biblioteca
          &lt;span id="libCount" style="color:var(--ink3)"&gt;0&lt;/span&gt;
        &lt;/div&gt;
        &lt;div id="libraryList"&gt;
          &lt;div class="layer-empty"&gt;Sem itens de identidade&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;

    &lt;input id="fileInput" type="file" accept=".svg,.png,.jpg,.jpeg,.webp,.ai,.eps,application/postscript,image/*" style="display:none"&gt;
  &lt;/aside&gt;

  &lt;!-- ═══ CANVAS AREA ════════════════════════════════════ --&gt;
  &lt;main class="canvas-area" id="canvasStage"&gt;
    &lt;div id="fabricCanvas"&gt;&lt;/div&gt;
    &lt;div class="artboard-plus-ui" id="artboardPlusUI"&gt;
      &lt;button class="ab-plus top" id="btnAddArtTop" title="Adicionar acima"&gt;+&lt;/button&gt;
      &lt;button class="ab-plus right" id="btnAddArtRight" title="Adicionar à direita"&gt;+&lt;/button&gt;
      &lt;button class="ab-plus bottom" id="btnAddArtBottom" title="Adicionar abaixo"&gt;+&lt;/button&gt;
      &lt;button class="ab-plus left" id="btnAddArtLeft" title="Adicionar à esquerda"&gt;+&lt;/button&gt;
    &lt;/div&gt;

    &lt;div class="floating-toolbar-wrap" id="floatingToolbar"&gt;
      &lt;div class="floating-toolbar-row top-tools" id="floatingTopTools"&gt;
        &lt;button class="float-tool-btn active" id="btnToolVector"&gt;Vetor&lt;/button&gt;
        &lt;button class="float-tool-btn" id="btnToolMove" data-tool="move"&gt;Mover&lt;/button&gt;
        &lt;button class="float-tool-btn" id="btnToolLasso"&gt;Laço&lt;/button&gt;
        &lt;button class="float-tool-btn" id="btnToolPaint"&gt;Pintar&lt;/button&gt;
        &lt;button class="float-tool-btn" id="btnToolCurve"&gt;Curvar&lt;/button&gt;
        &lt;button class="float-tool-btn" id="btnToolCut"&gt;Cortar&lt;/button&gt;
        &lt;button class="float-tool-btn" id="btnToolMore"&gt;Mais ▾&lt;/button&gt;
      &lt;/div&gt;
      &lt;div class="floating-toolbar-row fixed-tools"&gt;
        &lt;button class="float-tool-btn icon active" id="btnSelect" data-tool="select" title="Selecionar / mover"&gt;↖&lt;/button&gt;
        &lt;div class="tool-submenu" id="selectToolSubmenu"&gt;
          &lt;button class="tool-submenu-btn active" id="btnSelectNormal" data-tool="select"&gt;&lt;span&gt;Seleção&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;/button&gt;
          &lt;button class="tool-submenu-btn" id="btnSelectDirect" data-tool="direct-select"&gt;&lt;span&gt;Seleção direta&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/button&gt;
        &lt;/div&gt;
        &lt;button class="float-tool-btn icon" id="btnRect" title="Retângulo"&gt;▭&lt;/button&gt;
        &lt;button class="float-tool-btn icon" id="btnCircle" title="Círculo"&gt;◯&lt;/button&gt;
        &lt;button class="float-tool-btn icon" id="btnLine" title="Linha"&gt;／&lt;/button&gt;
        &lt;button class="float-tool-btn icon" id="btnBezier" title="Bezier"&gt;∿&lt;/button&gt;
        &lt;button class="float-tool-btn icon" id="btnTextTool" data-tool="text" title="Texto: clique (artístico) / arraste (caixa)"&gt;T&lt;/button&gt;
        &lt;div class="float-tool-sep"&gt;&lt;/div&gt;
        &lt;button class="float-tool-btn icon" id="btnUpload" title="Inserir imagem"&gt;▣&lt;/button&gt;
        &lt;button class="float-tool-btn icon" id="btnHelp" title="Atalhos"&gt;?&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="text-float-panel" id="textFloatPanel"&gt;
      &lt;div class="text-float-head"&gt;
        &lt;div class="text-float-tabs"&gt;
          &lt;button class="text-float-tab active" data-tf-tab="basico"&gt;Básico&lt;/button&gt;
          &lt;button class="text-float-tab" data-tf-tab="detalhes"&gt;Detalhes&lt;/button&gt;
          &lt;button class="text-float-tab" data-tf-tab="variavel"&gt;Variável&lt;/button&gt;
        &lt;/div&gt;
        &lt;button class="text-float-close" id="btnCloseTextFloat"&gt;✕&lt;/button&gt;
      &lt;/div&gt;
      &lt;div class="text-float-body"&gt;
        &lt;div data-pane="basico" class="active"&gt;
          &lt;div class="text-float-grid2"&gt;
            &lt;input class="field-input" id="tfFontSize" type="number" min="6" step="1" placeholder="Tamanho"&gt;
            &lt;input class="field-input" id="tfColor" type="color"&gt;
          &lt;/div&gt;
          &lt;div class="seg" id="tfAlignSeg"&gt;
            &lt;button class="seg-opt on" data-val="left"&gt;≡&lt;/button&gt;
            &lt;button class="seg-opt" data-val="center"&gt;≣&lt;/button&gt;
            &lt;button class="seg-opt" data-val="right"&gt;≡&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div data-pane="detalhes"&gt;
          &lt;div class="text-float-grid2"&gt;
            &lt;input class="field-input" id="tfLineHeight" type="number" min="0.6" max="4" step="0.1" placeholder="Entrelinha"&gt;
            &lt;input class="field-input" id="tfLetterSpacing" type="number" min="-50" max="200" step="1" placeholder="Espaçamento"&gt;
          &lt;/div&gt;
          &lt;div class="text-float-grid2"&gt;
            &lt;select class="field-input" id="tfWeight"&gt;&lt;option value="300"&gt;Light&lt;/option&gt;&lt;option value="400"&gt;Regular&lt;/option&gt;&lt;option value="500"&gt;Medium&lt;/option&gt;&lt;option value="600"&gt;SemiBold&lt;/option&gt;&lt;option value="700"&gt;Bold&lt;/option&gt;&lt;/select&gt;
            &lt;select class="field-input" id="tfStyle"&gt;&lt;option value="normal"&gt;Normal&lt;/option&gt;&lt;option value="italic"&gt;Itálico&lt;/option&gt;&lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div data-pane="variavel"&gt;
          &lt;div class="text-float-grid2"&gt;
            &lt;button class="tbtn" id="tfUnderline" style="justify-content:center"&gt;Sublinhado&lt;/button&gt;
            &lt;button class="tbtn" id="tfStrike" style="justify-content:center"&gt;Riscado&lt;/button&gt;
          &lt;/div&gt;
          &lt;div class="text-float-grid2"&gt;
            &lt;button class="tbtn" id="tfUppercase" style="justify-content:center"&gt;MAIÚSCULAS&lt;/button&gt;
            &lt;button class="tbtn" id="tfLowercase" style="justify-content:center"&gt;minúsculas&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

  &lt;/main&gt;

  &lt;!-- ═══ RIGHT PANEL ════════════════════════════════════ --&gt;
  &lt;aside class="panel right"&gt;
    &lt;div class="panel-body"&gt;
      &lt;div class="panel-tabs" id="propTabs"&gt;
        &lt;button class="panel-tab active" data-tab="cor"&gt;Cor&lt;/button&gt;
                &lt;button class="panel-tab" data-tab="tracado"&gt;Traçado&lt;/button&gt;
        &lt;button class="panel-tab" data-tab="aparencia"&gt;Aparência&lt;/button&gt;
      &lt;/div&gt;
      &lt;div data-tab-panel="cor"&gt;

      &lt;div class="panel-section"&gt;
        &lt;div class="panel-section-label"&gt;Informações&lt;/div&gt;
        &lt;div id="docInfoLabel" style="font-size:11px;font-family:'JetBrains Mono', ui-monospace, monospace;color:var(--ink3);padding:4px 0"&gt;Web • 1920×1080px • 72dpi&lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;div class="panel-section"&gt;
        &lt;div class="panel-section-label"&gt;Artboard&lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;label class="field-item"&gt;&lt;div class="field-label"&gt;Clip content&lt;/div&gt;&lt;input id="abClipContent" type="checkbox"&gt;&lt;/label&gt;
          &lt;label class="field-item"&gt;&lt;div class="field-label"&gt;Exportável&lt;/div&gt;&lt;input id="abExportEnabled" type="checkbox" checked&gt;&lt;/label&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;label class="field-item"&gt;&lt;div class="field-label"&gt;Background&lt;/div&gt;&lt;input id="abBgEnabled" type="checkbox" checked&gt;&lt;/label&gt;
          &lt;label class="field-item"&gt;&lt;div class="field-label"&gt;Lock BG&lt;/div&gt;&lt;input id="abBgLock" type="checkbox" checked&gt;&lt;/label&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;label class="field-item"&gt;&lt;div class="field-label"&gt;Cor BG&lt;/div&gt;&lt;input class="field-input" id="abBgColor" type="color" value="#ffffff"&gt;&lt;/label&gt;
          &lt;label class="field-item"&gt;&lt;div class="field-label"&gt;BG no export&lt;/div&gt;&lt;input id="abBgExport" type="checkbox" checked&gt;&lt;/label&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;div class="panel-section"&gt;
        &lt;div class="panel-section-label"&gt;Alinhamento&lt;/div&gt;
        &lt;div style="display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px"&gt;
          &lt;button class="tbtn" id="btnAlignLeft" title="Alinhar à esquerda" style="height:30px;justify-content:center"&gt;⟸&lt;/button&gt;
          &lt;button class="tbtn" id="btnAlignCenter" title="Centralizar horizontal" style="height:30px;justify-content:center"&gt;↔&lt;/button&gt;
          &lt;button class="tbtn" id="btnAlignRight" title="Alinhar à direita" style="height:30px;justify-content:center"&gt;⟹&lt;/button&gt;
          &lt;button class="tbtn" id="btnAlignTop" title="Alinhar no topo" style="height:30px;justify-content:center"&gt;⟰&lt;/button&gt;
          &lt;button class="tbtn" id="btnAlignMiddle" title="Centralizar vertical" style="height:30px;justify-content:center"&gt;↕&lt;/button&gt;
          &lt;button class="tbtn" id="btnAlignBottom" title="Alinhar na base" style="height:30px;justify-content:center"&gt;⟱&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;div class="panel-section"&gt;
        &lt;div class="panel-section-label"&gt;Exportar&lt;/div&gt;
        &lt;button class="tbtn" id="btnExportPanelPng" style="width:100%;justify-content:center;height:32px"&gt;Exportar PNG&lt;/button&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;!-- Selection info --&gt;
      &lt;div class="panel-section"&gt;
        &lt;div class="panel-section-label"&gt;Seleção&lt;/div&gt;
        &lt;div id="selInfo" style="font-size:11px;font-family:'JetBrains Mono', ui-monospace, monospace;color:var(--ink3);padding:4px 0"&gt;
          Nada selecionado
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;!-- Transform --&gt;
      &lt;div class="panel-section" id="propTransform"&gt;
        &lt;div class="panel-section-label"&gt;Transformação&lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;X&lt;/div&gt;&lt;input class="field-input" id="pX" type="number" step="1"&gt;&lt;/div&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Y&lt;/div&gt;&lt;input class="field-input" id="pY" type="number" step="1"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;W&lt;/div&gt;&lt;input class="field-input" id="pW" type="number" step="1" min="1"&gt;&lt;/div&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;H&lt;/div&gt;&lt;input class="field-input" id="pH" type="number" step="1" min="1"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Rot°&lt;/div&gt;&lt;input class="field-input" id="pR" type="number" step="1"&gt;&lt;/div&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Transp.&lt;/div&gt;&lt;input class="field-input" id="pO" type="range" min="0" max="1" step="0.01"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="prop-row"&gt;
          &lt;div class="field-item"&gt;
            &lt;div class="field-label"&gt;Blend mode&lt;/div&gt;
            &lt;select class="field-input" id="pBlend" style="height:32px"&gt;
              &lt;option value="source-over"&gt;Normal&lt;/option&gt;
              &lt;option value="multiply"&gt;Multiply&lt;/option&gt;
              &lt;option value="screen"&gt;Screen&lt;/option&gt;
              &lt;option value="overlay"&gt;Overlay&lt;/option&gt;
              &lt;option value="darken"&gt;Darken&lt;/option&gt;
              &lt;option value="lighten"&gt;Lighten&lt;/option&gt;
              &lt;option value="color-dodge"&gt;Color Dodge&lt;/option&gt;
              &lt;option value="color-burn"&gt;Color Burn&lt;/option&gt;
              &lt;option value="difference"&gt;Difference&lt;/option&gt;
              &lt;option value="exclusion"&gt;Exclusion&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;!-- Style --&gt;
      &lt;div class="panel-section" id="propStyle"&gt;
        &lt;div class="panel-section-label" style="display:flex;align-items:center;justify-content:space-between"&gt;Estilo &lt;button class="tbtn" id="btnAppearanceGear" title="Abrir painel de aparência" style="height:24px;padding:0 8px"&gt;⚙&lt;/button&gt;&lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Fill&lt;/div&gt;&lt;input class="field-input" id="pFill" type="color"&gt;&lt;/div&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Stroke&lt;/div&gt;&lt;input class="field-input" id="pStroke" type="color"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Espessura&lt;/div&gt;&lt;input class="field-input" id="pStrokeW" type="number" step="1" min="0"&gt;&lt;/div&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Raio&lt;/div&gt;&lt;input class="field-input" id="pRx" type="number" step="1" min="0"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;
            &lt;div class="field-label"&gt;Tipo Fill&lt;/div&gt;
            &lt;select class="field-input" id="pFillPaint" style="height:32px"&gt;
              &lt;option value="solid"&gt;Sólido&lt;/option&gt;
              &lt;option value="gradient"&gt;Gradiente&lt;/option&gt;
              &lt;option value="pattern"&gt;Padrão&lt;/option&gt;
              &lt;option value="filter"&gt;Filtro&lt;/option&gt;
              &lt;option value="none"&gt;(nenhum)&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          &lt;div class="field-item"&gt;
            &lt;div class="field-label"&gt;Tipo Stroke&lt;/div&gt;
            &lt;select class="field-input" id="pStrokePaint" style="height:32px"&gt;
              &lt;option value="solid"&gt;Sólido&lt;/option&gt;
              &lt;option value="gradient"&gt;Gradiente&lt;/option&gt;
              &lt;option value="pattern"&gt;Padrão&lt;/option&gt;
              &lt;option value="filter"&gt;Filtro&lt;/option&gt;
              &lt;option value="none"&gt;(nenhum)&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class="sep"&gt;&lt;/div&gt;

      &lt;!-- Text --&gt;
      &lt;div class="panel-section" id="propText"&gt;
        &lt;div class="panel-section-label" style="display:flex;align-items:center;justify-content:space-between"&gt;Texto &lt;button class="tbtn" id="btnTypographyGear" title="Abrir painel de tipografia" style="height:24px;padding:0 8px"&gt;⚙&lt;/button&gt;&lt;/div&gt;
        &lt;div class="prop-row"&gt;
          &lt;div class="field-item"&gt;
            &lt;div class="field-label"&gt;Fonte&lt;/div&gt;
            &lt;select class="field-input" id="pFont" style="height:32px"&gt;
              &lt;option value="Outfit"&gt;Outfit&lt;/option&gt;
              &lt;option value="Syne"&gt;Syne&lt;/option&gt;
              &lt;option value="Sora"&gt;Sora&lt;/option&gt;
              &lt;option value="DM Sans"&gt;DM Sans&lt;/option&gt;
              &lt;option value="Nunito"&gt;Nunito&lt;/option&gt;
              &lt;option value="Poppins"&gt;Poppins&lt;/option&gt;
              &lt;option value="Montserrat"&gt;Montserrat&lt;/option&gt;
              &lt;option value="IBM Plex Sans"&gt;IBM Plex Sans&lt;/option&gt;
              &lt;option value="Raleway"&gt;Raleway&lt;/option&gt;
              &lt;option value="Manrope"&gt;Manrope&lt;/option&gt;
              &lt;option value="Inter"&gt;Inter&lt;/option&gt;
              &lt;option value="Roboto"&gt;Roboto&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;
            &lt;div class="field-label"&gt;Google Font&lt;/div&gt;
            &lt;input class="field-input" id="pGoogleFont" placeholder="Ex: Playfair Display"&gt;
          &lt;/div&gt;
          &lt;button class="tbtn" id="btnLoadFont" style="justify-content:center;height:32px;align-self:end"&gt;Carregar&lt;/button&gt;
        &lt;/div&gt;
        &lt;div class="prop-grid2 prop-row"&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Tamanho&lt;/div&gt;&lt;input class="field-input" id="pFontSize" type="number" step="1" min="6"&gt;&lt;/div&gt;
          &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Cor&lt;/div&gt;&lt;input class="field-input" id="pTextColor" type="color"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="prop-row"&gt;
          &lt;div class="field-label" style="margin-bottom:6px"&gt;Alinhamento&lt;/div&gt;
          &lt;div class="seg" id="alignSeg"&gt;
            &lt;button class="seg-opt on" data-val="left"&gt;≡&lt;/button&gt;
            &lt;button class="seg-opt" data-val="center"&gt;≣&lt;/button&gt;
            &lt;button class="seg-opt" data-val="right"&gt;≡&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div data-tab-panel="tracado" style="display:none"&gt;
        &lt;div class="panel-section"&gt;
          &lt;div class="panel-section-label"&gt;Traçado&lt;/div&gt;
          &lt;div class="rp-row"&gt;
            &lt;span class="rp-chip"&gt;Estilo&lt;/span&gt;
            &lt;button class="rp-icon-btn active" data-stroke-style="solid"&gt;Sólido&lt;/button&gt;
            &lt;button class="rp-icon-btn" data-stroke-style="dash"&gt;Tracejado&lt;/button&gt;
            &lt;button class="rp-icon-btn" data-stroke-style="dot"&gt;Pontilhado&lt;/button&gt;
          &lt;/div&gt;
          &lt;div class="prop-grid2 prop-row"&gt;
            &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Cor de traço&lt;/div&gt;&lt;input class="field-input" id="pStroke2" type="color"&gt;&lt;/div&gt;
            &lt;div class="field-item"&gt;&lt;div class="field-label"&gt;Espessura&lt;/div&gt;&lt;input class="field-input" id="pStrokeW2" type="number" step="1" min="0"&gt;&lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="rp-row"&gt;
            &lt;input class="rp-stroke-range rp-grow" id="pStrokeWRange2" type="range" min="0" max="120" step="1"&gt;
          &lt;/div&gt;
          &lt;div class="rp-row"&gt;
            &lt;span class="rp-chip"&gt;Tampa&lt;/span&gt;
            &lt;button class="rp-icon-btn active" data-stroke-cap="butt"&gt;▮&lt;/button&gt;
            &lt;button class="rp-icon-btn" data-stroke-cap="round"&gt;◖&lt;/button&gt;
            &lt;button class="rp-icon-btn" data-stroke-cap="square"&gt;▭&lt;/button&gt;
            &lt;span class="rp-chip" style="margin-left:auto"&gt;Mitra&lt;/span&gt;
            &lt;input class="field-input" id="pMiter2" type="number" min="1" max="10" step="0.5" value="1.5" style="width:64px"&gt;
          &lt;/div&gt;
          &lt;div class="rp-row"&gt;
            &lt;span class="rp-chip"&gt;Unir&lt;/span&gt;
            &lt;button class="rp-icon-btn active" data-stroke-join="miter"&gt;┌&lt;/button&gt;
            &lt;button class="rp-icon-btn" data-stroke-join="round"&gt;◜&lt;/button&gt;
            &lt;button class="rp-icon-btn" data-stroke-join="bevel"&gt;⌟&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div data-tab-panel="aparencia" style="display:none"&gt;
        &lt;div class="panel-section"&gt;
          &lt;div class="panel-section-label"&gt;Aparência&lt;/div&gt;
          &lt;div class="prop-grid2 prop-row"&gt;
            &lt;div class="field-item"&gt;
              &lt;div class="field-label"&gt;Modo de mesclagem&lt;/div&gt;
              &lt;select class="field-input" id="pBlend2" style="height:32px"&gt;
                &lt;option value="source-over"&gt;Normal&lt;/option&gt;
                &lt;option value="multiply"&gt;Multiply&lt;/option&gt;
                &lt;option value="screen"&gt;Screen&lt;/option&gt;
                &lt;option value="overlay"&gt;Overlay&lt;/option&gt;
                &lt;option value="darken"&gt;Darken&lt;/option&gt;
                &lt;option value="lighten"&gt;Lighten&lt;/option&gt;
              &lt;/select&gt;
            &lt;/div&gt;
            &lt;div class="field-item"&gt;
              &lt;div class="field-label"&gt;Opacidade&lt;/div&gt;
              &lt;input class="field-input" id="pOpacity2" type="number" min="0" max="100" step="1" value="100"&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="rp-row"&gt;&lt;input class="rp-stroke-range rp-grow" id="pOpacityRange2" type="range" min="0" max="100" step="1" value="100"&gt;&lt;/div&gt;
          &lt;div class="sep"&gt;&lt;/div&gt;
          &lt;div class="panel-section-label"&gt;Pilhas de preenchimento&lt;/div&gt;
          &lt;div class="rp-row"&gt;&lt;button class="tbtn" id="btnAddFillLayer" style="height:30px;justify-content:center"&gt;+ Fill&lt;/button&gt;&lt;/div&gt;
          &lt;div id="appearanceFillList" class="appearance-list"&gt;&lt;/div&gt;
          &lt;div class="sep"&gt;&lt;/div&gt;
          &lt;div class="panel-section-label"&gt;Pilhas de traçado&lt;/div&gt;
          &lt;div class="rp-row"&gt;&lt;button class="tbtn" id="btnAddStrokeLayer" style="height:30px;justify-content:center"&gt;+ Traço&lt;/button&gt;&lt;/div&gt;
          &lt;div id="appearanceStrokeList" class="appearance-list"&gt;&lt;/div&gt;
          &lt;div class="sep"&gt;&lt;/div&gt;
          &lt;div class="panel-section-label"&gt;Clip mask&lt;/div&gt;
          &lt;div class="prop-grid2 prop-row"&gt;
            &lt;button class="tbtn" id="btnClipMask" style="justify-content:center;height:30px"&gt;Aplicar clip&lt;/button&gt;
            &lt;button class="tbtn" id="btnReleaseClip" style="justify-content:center;height:30px"&gt;Soltar clip&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;
  &lt;/aside&gt;

&lt;/div&gt;&lt;!-- .app --&gt;


&lt;div class="ctx-pop" id="canvasCtx"&gt;
  &lt;div class="ctx-pop-item" data-act="paste"&gt;&lt;span&gt;Colar&lt;/span&gt;&lt;span&gt;Ctrl+V&lt;/span&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-item" data-act="group"&gt;&lt;span&gt;Agrupar&lt;/span&gt;&lt;span&gt;Ctrl+G&lt;/span&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-item" data-act="ungroup"&gt;&lt;span&gt;Desagrupar&lt;/span&gt;&lt;span&gt;Ctrl+Shift+G&lt;/span&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-sep"&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-item" data-act="front"&gt;&lt;span&gt;Trazer para frente&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-item" data-act="back"&gt;&lt;span&gt;Enviar para trás&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-sep"&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-item" data-act="duplicate"&gt;&lt;span&gt;Duplicar&lt;/span&gt;&lt;span&gt;Ctrl+D&lt;/span&gt;&lt;/div&gt;
  &lt;div class="ctx-pop-item" data-act="delete"&gt;&lt;span&gt;Excluir&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- ═══ MODAL ════════════════════════════════════════════ --&gt;
&lt;div class="modal-bg" id="modalBg"&gt;
  &lt;div class="modal-box"&gt;
    &lt;div class="modal-head"&gt;
      &lt;div class="modal-title" id="modalTitle"&gt;Modal&lt;/div&gt;
      &lt;button class="tbtn" id="btnCloseModal"&gt;✕&lt;/button&gt;
    &lt;/div&gt;
    &lt;div class="modal-body" id="modalBody"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
if(!window.fabric){
  document.body.innerHTML = "&lt;div style=\"min-height:100vh;display:grid;place-items:center;background:#0e0e11;color:#f0eff4;font-family:Outfit,system-ui;padding:24px;text-align:center\"&gt;&lt;div&gt;&lt;b&gt;Editor indisponível&lt;/b&gt;&lt;br/&gt;&lt;span style=\"opacity:.75\"&gt;Não foi possível carregar o Fabric.js. Verifique a conexão e tente novamente.&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;";
  throw new Error("Fabric.js failed to load");
}

const textBaselineDescriptor = Object.getOwnPropertyDescriptor(CanvasRenderingContext2D.prototype, 'textBaseline');
if (textBaselineDescriptor?.set &amp;&amp; textBaselineDescriptor.configurable) {
  Object.defineProperty(CanvasRenderingContext2D.prototype, 'textBaseline', {
    configurable: true,
    enumerable: textBaselineDescriptor.enumerable,
    get: textBaselineDescriptor.get,
    set(value) {
      const normalized = value === 'alphabetical' ? 'alphabetic' : value;
      textBaselineDescriptor.set.call(this, normalized);
    }
  });
}

const $ = id =&gt; document.getElementById(id);
const clamp = (n,a,b) =&gt; Math.max(a, Math.min(b, n));

// ─── Fabric canvas ───────────────────────────────────────
const fabricHost = $('fabricCanvas');
const canvasEl = document.createElement('canvas');
canvasEl.id = 'c';
fabricHost.appendChild(canvasEl);

const canvas = new fabric.Canvas('c', {
  preserveObjectStacking: true,
  selection: true,
  fireRightClick: true,
  stopContextMenu: true
});

canvas.selectionColor = 'rgba(47,155,255,.08)';
canvas.selectionBorderColor = '#2f9bff';
canvas.selectionLineWidth = 1.2;
fabric.Object.prototype.borderColor = '#2f9bff';
fabric.Object.prototype.cornerColor = '#ffffff';
fabric.Object.prototype.cornerStrokeColor = '#2f9bff';
fabric.Object.prototype.cornerStyle = 'rect';
fabric.Object.prototype.transparentCorners = false;
fabric.Object.prototype.cornerSize = 8;

const stageEl = $('canvasStage');

// Document state
let docW = 1200, docH = 750;
let deskBg = '#0f1626';
let zoom = 1;
let isPanning = false, isSpaceDown = false;
let lastX = 0, lastY = 0;
let artboardMode = false;
let activeTool = 'select';
const ENABLE_BEZIER_V2 = true;
let textDragStart = null;
let textDragMoved = false;

const smartOverlayState = {
  guides: [],
  measurements: [],
  equalSpacing: [],
  liveMeasure: false
};


function clearSmartOverlayState({keepMeasurements=false}={}){
  smartOverlayState.guides = [];
  smartOverlayState.equalSpacing = [];
  smartOverlayState.liveMeasure = false;
  if(!keepMeasurements) smartOverlayState.measurements = [];
}
const smartSnapState = { enabled:true, threshold:6 };
let isAltMeasureDown = false;
const twoItemOverlay = {
  root: null,
  swap: null,
  gap: null,
  drag: null,
  refs: null
};

function isEditorAuxObject(obj){
  return !obj || isGuide(obj) || obj.isBezierEditorControl || obj.isBezierOverlay || obj.excludeFromExport;
}

function getBounds(obj){
  const b = obj.getBoundingRect(true, true);
  return {
    left:b.left,
    top:b.top,
    right:b.left + b.width,
    bottom:b.top + b.height,
    width:b.width,
    height:b.height,
    centerX:b.left + b.width/2,
    centerY:b.top + b.height/2
  };
}


function moveObjectByDelta(obj, dx=0, dy=0){
  if(!obj || (!dx && !dy)) return;
  const c = obj.getCenterPoint();
  obj.setPositionByOrigin(new fabric.Point(c.x + dx, c.y + dy), 'center', 'center');
  obj.setCoords();
}

function getUnionBounds(objs=[]){
  if(!objs.length) return null;
  const list = objs.map(getBounds);
  const left = Math.min(...list.map(b=&gt;b.left));
  const top = Math.min(...list.map(b=&gt;b.top));
  const right = Math.max(...list.map(b=&gt;b.right));
  const bottom = Math.max(...list.map(b=&gt;b.bottom));
  return { left, top, right, bottom, width:right-left, height:bottom-top, centerX:(left+right)/2, centerY:(top+bottom)/2 };
}

function worldToScreen(x,y){
  const v = canvas.viewportTransform || [1,0,0,1,0,0];
  return { x:x*v[0] + v[4], y:y*v[3] + v[5] };
}

function ensureTwoItemOverlay(){
  if(twoItemOverlay.root) return;
  const root = document.createElement('div');
  root.className = 'smart-two-overlay';
  root.innerHTML = `
    &lt;button class="smart-swap-btn" id="smartSwapBtn" title="Inverter ordem (swap)"&gt;⇄&lt;/button&gt;
    &lt;button class="smart-gap-handle" id="smartGapHandle" title="Ajustar espaçamento"&gt;&lt;/button&gt;
  `;
  stageEl.appendChild(root);
  twoItemOverlay.root = root;
  twoItemOverlay.swap = root.querySelector('#smartSwapBtn');
  twoItemOverlay.gap = root.querySelector('#smartGapHandle');

  twoItemOverlay.swap.addEventListener('click', e =&gt; {
    e.preventDefault(); e.stopPropagation();
    const refs = twoItemOverlay.refs;
    if(!refs || refs.items.length !== 2) return;
    const [a,b] = refs.items;
    const ap = a.getCenterPoint();
    const bp = b.getCenterPoint();
    a.setPositionByOrigin(bp, 'center', 'center');
    b.setPositionByOrigin(ap, 'center', 'center');
    a.setCoords();
    b.setCoords();
    canvas.requestRenderAll();
    refreshProps();
    refreshLayers();
    snapshot();
    setStatus('Posições invertidas');
  });

  twoItemOverlay.gap.addEventListener('mousedown', e =&gt; {
    e.preventDefault(); e.stopPropagation();
    const refs = twoItemOverlay.refs;
    if(!refs || refs.items.length !== 2) return;
    const [rawA,rawB] = refs.items;
    const axis = refs.axis;
    const [a,b] = axis === 'x'
      ? [rawA,rawB].sort((x,y)=&gt;getBounds(x).left - getBounds(y).left)
      : [rawA,rawB].sort((x,y)=&gt;getBounds(x).top - getBounds(y).top);
    const ba = getBounds(a);
    const bb = getBounds(b);
    const gapStart = axis === 'x' ? bb.left - ba.right : bb.top - ba.bottom;
    twoItemOverlay.drag = {
      axis,
      a,
      b,
      startMouse: { x:e.clientX, y:e.clientY },
      startGap: gapStart
    };
    document.body.classList.add('is-dragging-gap');
  });

  window.addEventListener('mousemove', e =&gt; {
    const drag = twoItemOverlay.drag;
    if(!drag) return;
    const axis = drag.axis;
    const delta = axis === 'x' ? (e.clientX - drag.startMouse.x) / (canvas.getZoom() || 1) : (e.clientY - drag.startMouse.y) / (canvas.getZoom() || 1);
    const nextGap = drag.startGap + delta;
    const aBounds = getBounds(drag.a);
    const bBounds = getBounds(drag.b);
    if(axis === 'x') {
      const targetLeft = aBounds.right + nextGap;
      drag.b.set({ left: (drag.b.left || 0) + (targetLeft - bBounds.left) });
    } else {
      const targetTop = aBounds.bottom + nextGap;
      drag.b.set({ top: (drag.b.top || 0) + (targetTop - bBounds.top) });
    }
    drag.b.setCoords();
    refreshSmartMeasurementState();
    canvas.requestRenderAll();
    refreshProps();
  });

  const stopDrag = () =&gt; {
    if(!twoItemOverlay.drag) return;
    twoItemOverlay.drag = null;
    document.body.classList.remove('is-dragging-gap');
    refreshLayers();
    snapshot();
  };
  window.addEventListener('mouseup', stopDrag);
}

function hideTwoItemOverlay(){
  ensureTwoItemOverlay();
  twoItemOverlay.root?.classList.remove('show-swap','show-gap');
  twoItemOverlay.refs = null;
}

function updateTwoItemOverlay(){
  ensureTwoItemOverlay();
  const objs = selectedObjects();
  if(objs.length &lt; 2){ hideTwoItemOverlay(); return; }

  const active = canvas.getActiveObject();
  let union = getUnionBounds(objs);
  if(active &amp;&amp; active.type === 'activeSelection') {
    const b = active.getBoundingRect(true, true);
    union = {
      left:b.left, top:b.top,
      right:b.left+b.width, bottom:b.top+b.height,
      width:b.width, height:b.height,
      centerX:b.left + b.width/2,
      centerY:b.top + b.height/2
    };
  }
  if(!union){ hideTwoItemOverlay(); return; }

  const c = worldToScreen(union.centerX, union.centerY);
  twoItemOverlay.swap.style.left = `${Math.round(c.x - 12)}px`;
  twoItemOverlay.swap.style.top = `${Math.round(c.y - 12)}px`;
  twoItemOverlay.root.classList.add('show-swap');
  twoItemOverlay.refs = { items: objs.slice(), axis:'x' };

  if(objs.length !== 2){
    twoItemOverlay.root.classList.remove('show-gap');
    return;
  }

  const b0 = getBounds(objs[0]);
  const b1 = getBounds(objs[1]);
  const horizontal = Math.abs(b0.centerY - b1.centerY) &lt;= Math.abs(b0.centerX - b1.centerX);
  const axis = horizontal ? 'x' : 'y';
  twoItemOverlay.refs = { items: objs.slice(), axis };

  if(horizontal){
    const leftObj = b0.left &lt;= b1.left ? b0 : b1;
    const rightObj = leftObj === b0 ? b1 : b0;
    const x = (leftObj.right + rightObj.left) / 2;
    const y = (leftObj.centerY + rightObj.centerY) / 2;
    const p = worldToScreen(x, y);
    twoItemOverlay.gap.style.left = `${Math.round(p.x - 2)}px`;
    twoItemOverlay.gap.style.top = `${Math.round(p.y - 12)}px`;
    twoItemOverlay.gap.style.width = `4px`;
    twoItemOverlay.gap.style.height = `24px`;
  } else {
    const topObj = b0.top &lt;= b1.top ? b0 : b1;
    const bottomObj = topObj === b0 ? b1 : b0;
    const x = (topObj.centerX + bottomObj.centerX) / 2;
    const y = (topObj.bottom + bottomObj.top) / 2;
    const p = worldToScreen(x, y);
    twoItemOverlay.gap.style.left = `${Math.round(p.x - 12)}px`;
    twoItemOverlay.gap.style.top = `${Math.round(p.y - 2)}px`;
    twoItemOverlay.gap.style.width = `24px`;
    twoItemOverlay.gap.style.height = `4px`;
  }
  twoItemOverlay.root.classList.add('show-gap');
}

function renderSmartOverlays(){
  const ctx = canvas.contextTop;
  if(!ctx) return;
  const v = canvas.viewportTransform || [1,0,0,1,0,0];
  const toScreen = p =&gt; ({ x:p.x * v[0] + v[4], y:p.y * v[3] + v[5] });

  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
  ctx.lineWidth = 1;
  ctx.font = '11px "JetBrains Mono", monospace';

  const drawLine = (a,b,color='#7f5af0',dash=[]) =&gt; {
    const p1 = toScreen(a); const p2 = toScreen(b);
    ctx.strokeStyle = color;
    ctx.setLineDash(dash);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    return { p1, p2 };
  };

  const drawLabel = (txt, x, y, color='#7f5af0') =&gt; {
    const p = toScreen({x,y});
    const w = ctx.measureText(txt).width + 8;
    ctx.fillStyle = 'rgba(15,18,28,.88)';
    ctx.fillRect(p.x - w/2, p.y - 9, w, 16);
    ctx.strokeStyle = color;
    ctx.strokeRect(p.x - w/2, p.y - 9, w, 16);
    ctx.fillStyle = '#fff';
    ctx.fillText(txt, p.x - w/2 + 4, p.y + 3);
  };

  smartOverlayState.guides.forEach(g =&gt; {
    drawLine(g.a, g.b, '#7f5af0');
    if(g.label) drawLabel(g.label, (g.a.x+g.b.x)/2, (g.a.y+g.b.y)/2 - 10, '#7f5af0');
  });

  smartOverlayState.measurements.forEach(m =&gt; {
    drawLine(m.a, m.b, '#2cb67d', m.dash || []);
    drawLabel(m.label, (m.a.x+m.b.x)/2, (m.a.y+m.b.y)/2, '#2cb67d');
  });

  smartOverlayState.equalSpacing.forEach(g =&gt; {
    drawLine(g.a, g.b, '#32d296', [4,4]);
    if(g.label) drawLabel(g.label, (g.a.x+g.b.x)/2, (g.a.y+g.b.y)/2 - 10, '#32d296');
  });

  ctx.restore();
}

function refreshSmartMeasurementState(){
  smartOverlayState.measurements = [];
  const sel = selectedObjects();
  if((!isAltMeasureDown &amp;&amp; !smartOverlayState.liveMeasure) || !sel.length) return;

  const bounds = getUnionBounds(sel);
  if(!bounds) return;
  const selectedArtboardId = sel.find(o =&gt; o?.dataArtboardId)?.dataArtboardId || null;
  const others = canvas.getObjects().filter(o =&gt; {
    if (isEditorAuxObject(o) || sel.includes(o)) return false;
    if (!selectedArtboardId) return true;
    return o?.dataArtboardId === selectedArtboardId;
  });

  const pick = { left:null, right:null, top:null, bottom:null };
  others.forEach(obj =&gt; {
    const b = getBounds(obj);
    const overlapY = Math.min(bounds.bottom, b.bottom) - Math.max(bounds.top, b.top);
    const overlapX = Math.min(bounds.right, b.right) - Math.max(bounds.left, b.left);

    if(overlapY &gt; 0){
      if(b.right &lt;= bounds.left){
        const d = bounds.left - b.right;
        if(!pick.left || d &lt; pick.left.d) pick.left = { d, a:{x:b.right, y:(Math.max(bounds.top,b.top)+Math.min(bounds.bottom,b.bottom))/2}, b:{x:bounds.left, y:(Math.max(bounds.top,b.top)+Math.min(bounds.bottom,b.bottom))/2} };
      }
      if(b.left &gt;= bounds.right){
        const d = b.left - bounds.right;
        if(!pick.right || d &lt; pick.right.d) pick.right = { d, a:{x:bounds.right, y:(Math.max(bounds.top,b.top)+Math.min(bounds.bottom,b.bottom))/2}, b:{x:b.left, y:(Math.max(bounds.top,b.top)+Math.min(bounds.bottom,b.bottom))/2} };
      }
    }

    if(overlapX &gt; 0){
      if(b.bottom &lt;= bounds.top){
        const d = bounds.top - b.bottom;
        if(!pick.top || d &lt; pick.top.d) pick.top = { d, a:{x:(Math.max(bounds.left,b.left)+Math.min(bounds.right,b.right))/2, y:b.bottom}, b:{x:(Math.max(bounds.left,b.left)+Math.min(bounds.right,b.right))/2, y:bounds.top} };
      }
      if(b.top &gt;= bounds.bottom){
        const d = b.top - bounds.bottom;
        if(!pick.bottom || d &lt; pick.bottom.d) pick.bottom = { d, a:{x:(Math.max(bounds.left,b.left)+Math.min(bounds.right,b.right))/2, y:bounds.bottom}, b:{x:(Math.max(bounds.left,b.left)+Math.min(bounds.right,b.right))/2, y:b.top} };
      }
    }
  });

  Object.values(pick).forEach(v =&gt; {
    if(!v) return;
    smartOverlayState.measurements.push({ a:v.a, b:v.b, label:`${Math.round(v.d)} px` });
  });

  if(sel.length===2){
    const b0 = getBounds(sel[0]);
    const b1 = getBounds(sel[1]);
    const overlapY = Math.min(b0.bottom,b1.bottom) - Math.max(b0.top,b1.top);
    const overlapX = Math.min(b0.right,b1.right) - Math.max(b0.left,b1.left);
    if(overlapY &gt; 0){
      const left = b0.left &lt; b1.left ? b0 : b1;
      const right = left===b0 ? b1 : b0;
      const d = right.left - left.right;
      smartOverlayState.measurements.push({ a:{x:left.right,y:(left.centerY+right.centerY)/2}, b:{x:right.left,y:(left.centerY+right.centerY)/2}, label:`${Math.round(d)} px` });
    }
    if(overlapX &gt; 0){
      const top = b0.top &lt; b1.top ? b0 : b1;
      const bottom = top===b0 ? b1 : b0;
      const d = bottom.top - top.bottom;
      smartOverlayState.measurements.push({ a:{x:(top.centerX+bottom.centerX)/2,y:top.bottom}, b:{x:(top.centerX+bottom.centerX)/2,y:bottom.top}, label:`${Math.round(d)} px` });
    }
  }
}

function refreshEqualSpacingHints(){
  smartOverlayState.equalSpacing = [];
  const sel = selectedObjects();
  if(sel.length &lt; 3) return;
  const sortedX = sel.slice().sort((a,b)=&gt;getBounds(a).left - getBounds(b).left).map(getBounds);
  const gapX1 = sortedX[1].left - sortedX[0].right;
  const gapX2 = sortedX[2].left - sortedX[1].right;
  if (Number.isFinite(gapX1) &amp;&amp; Number.isFinite(gapX2) &amp;&amp; Math.abs(gapX1-gapX2) &lt;= 2) {
    smartOverlayState.equalSpacing.push({
      a:{x:sortedX[0].right, y:sortedX[0].centerY},
      b:{x:sortedX[1].left, y:sortedX[1].centerY},
      label:`=${Math.round(gapX1)}px`
    });
    smartOverlayState.equalSpacing.push({
      a:{x:sortedX[1].right, y:sortedX[1].centerY},
      b:{x:sortedX[2].left, y:sortedX[2].centerY},
      label:`=${Math.round(gapX2)}px`
    });
  }
}

function refreshAlignmentAssist(){
  refreshSmartMeasurementState();
  refreshEqualSpacingHints();
  updateTwoItemOverlay();
}

function applySmartSnap(target){
  smartOverlayState.guides = [];
  if(!smartSnapState.enabled || !target || isEditorAuxObject(target)) return;
  const moving = getBounds(target);
  const members = target.type === 'activeSelection' ? target.getObjects() : [target];
  const selectedArtboardId = members.find(o =&gt; o?.dataArtboardId)?.dataArtboardId || target?.dataArtboardId || null;
  const others = canvas.getObjects().filter(o =&gt; {
    if (isEditorAuxObject(o) || members.includes(o)) return false;
    if (!selectedArtboardId) return true;
    return o?.dataArtboardId === selectedArtboardId;
  });
  if(!others.length) return;
  const threshold = smartSnapState.threshold / (canvas.getZoom() || 1);

  let bestX = null;
  let bestY = null;
  let equalWidthHint = null;
  let equalHeightHint = null;

  const own = {
    left:moving.left,
    right:moving.right,
    centerX:moving.centerX,
    top:moving.top,
    bottom:moving.bottom,
    centerY:moving.centerY,
    width:moving.width,
    height:moving.height
  };

  others.forEach(obj =&gt; {
    const b = getBounds(obj);
    const xPairs = [
      { self:own.left, other:b.left, label:'L' },
      { self:own.left, other:b.right, label:'↔' },
      { self:own.right, other:b.left, label:'↔' },
      { self:own.right, other:b.right, label:'R' },
      { self:own.centerX, other:b.centerX, label:'C' }
    ];
    xPairs.forEach(pair =&gt; {
      const d = pair.other - pair.self;
      if(Math.abs(d) &lt;= threshold &amp;&amp; (!bestX || Math.abs(d) &lt; Math.abs(bestX.delta))) {
        bestX = { delta:d, x:pair.other, minY:Math.min(own.top,b.top), maxY:Math.max(own.bottom,b.bottom), label:pair.label };
      }
    });

    const yPairs = [
      { self:own.top, other:b.top, label:'T' },
      { self:own.top, other:b.bottom, label:'↕' },
      { self:own.bottom, other:b.top, label:'↕' },
      { self:own.bottom, other:b.bottom, label:'B' },
      { self:own.centerY, other:b.centerY, label:'M' }
    ];
    yPairs.forEach(pair =&gt; {
      const d = pair.other - pair.self;
      if(Math.abs(d) &lt;= threshold &amp;&amp; (!bestY || Math.abs(d) &lt; Math.abs(bestY.delta))) {
        bestY = { delta:d, y:pair.other, minX:Math.min(own.left,b.left), maxX:Math.max(own.right,b.right), label:pair.label };
      }
    });

    const wDiff = Math.abs(own.width - b.width);
    if(wDiff &lt;= threshold &amp;&amp; (!equalWidthHint || wDiff &lt; equalWidthHint.diff)){
      equalWidthHint = {
        diff: wDiff,
        guide: { a:{x:Math.min(own.left,b.left), y:Math.max(own.top,b.top)-8}, b:{x:Math.max(own.right,b.right), y:Math.max(own.top,b.top)-8}, label:'Largura igual' }
      };
    }
    const hDiff = Math.abs(own.height - b.height);
    if(hDiff &lt;= threshold &amp;&amp; (!equalHeightHint || hDiff &lt; equalHeightHint.diff)){
      equalHeightHint = {
        diff: hDiff,
        guide: { a:{x:Math.max(own.left,b.left)-8, y:Math.min(own.top,b.top)}, b:{x:Math.max(own.left,b.left)-8, y:Math.max(own.bottom,b.bottom)}, label:'Altura igual' }
      };
    }
  });

  if(equalWidthHint) smartOverlayState.guides.push(equalWidthHint.guide);
  if(equalHeightHint) smartOverlayState.guides.push(equalHeightHint.guide);

  const snapDx = bestX ? bestX.delta : 0;
  const snapDy = bestY ? bestY.delta : 0;
  if (snapDx || snapDy) moveObjectByDelta(target, snapDx, snapDy);

  const snapped = (snapDx || snapDy) ? getBounds(target) : own;
  if(bestX){
    smartOverlayState.guides.push({ a:{x:bestX.x, y:Math.min(snapped.top, bestX.minY)-40}, b:{x:bestX.x, y:Math.max(snapped.bottom, bestX.maxY)+40}, label:'snap X' });
  }
  if(bestY){
    smartOverlayState.guides.push({ a:{x:Math.min(snapped.left, bestY.minX)-40, y:bestY.y}, b:{x:Math.max(snapped.right, bestY.maxX)+40, y:bestY.y}, label:'snap Y' });
  }
}


// Artboard objects
let artboard = null, artboardShadow = null, bleedRect = null, safeRect = null;
const artboards = [];
let activeArtboardId = null;
const ART_GAP = 120;
const GUIDES = { bleed: 0, safe: 24 };

// ─── Canvas sizing ──────────────────────────────────────
function resizeCanvasToViewport() {
  const r = stageEl.getBoundingClientRect();
  const w = Math.floor(r.width);
  const h = Math.floor(r.height);
  if (w &gt; 10 &amp;&amp; h &gt; 10) {
    fabricHost.style.width  = w + 'px';
    fabricHost.style.height = h + 'px';
    canvas.setWidth(w);
    canvas.setHeight(h);
    canvas.requestRenderAll();
  }
}

// ─── Mesa (workspace bg) ────────────────────────────────
function setDeskBg(color) {
  deskBg = color;
  stageEl.style.setProperty('--desk-color', color);
  canvas.backgroundColor = 'transparent';
}

function setDeskTheme(theme) {
  const map = {
    nebula: {
      bg: `radial-gradient(ellipse 60% 50% at 25% 20%, rgba(127,90,240,.16), transparent), radial-gradient(ellipse 50% 60% at 75% 80%, rgba(44,182,125,.10), transparent), ${deskBg}`,
      dot: 'rgba(255,255,255,.08)'
    },
    clean: { bg: `${deskBg}`, dot: 'rgba(255,255,255,.06)' },
    paper: {
      bg: `linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)), ${deskBg}`,
      dot: 'rgba(0,0,0,.10)'
    },
    mint: {
      bg: `radial-gradient(circle at 15% 15%, rgba(44,182,125,.24), transparent 35%), radial-gradient(circle at 85% 80%, rgba(127,90,240,.2), transparent 35%), ${deskBg}`,
      dot: 'rgba(255,255,255,.07)'
    }
  };
  const t = map[theme] || map.nebula;
  stageEl.style.setProperty('--desk-bg', t.bg);
  stageEl.style.setProperty('--desk-dot', t.dot);
}

// ─── Artboard ────────────────────────────────────────────
const artboardCreateState = { active:false, start:null, ghost:null };

function isGuide(o) {
  return artboards.some(a =&gt; o===a.board || o===a.shadow || o===a.bleed || o===a.safe);
}

function getArtboardById(id){
  return artboards.find(a =&gt; a.id === id) || null;
}

function getActiveArtboard() {
  return getArtboardById(activeArtboardId);
}

function getArtboardByBoard(boardObj){
  return artboards.find(a =&gt; a.board === boardObj) || null;
}

function syncActiveArtboardRefs() {
  const current = getActiveArtboard();
  if (!current) return;
  artboard = current.board;
  artboardShadow = current.shadow;
  bleedRect = current.bleed;
  safeRect = current.safe;
  docW = current.w;
  docH = current.h;
  if ($('abW')) $('abW').value = String(Math.round(docW));
  if ($('abH')) $('abH').value = String(Math.round(docH));
  refreshArtboardInspector();
}

function pointInArtboard(ab, point){
  if (!ab || !point) return false;
  const L = ab.board.left, T = ab.board.top, R = L + ab.w, B = T + ab.h;
  return point.x &gt;= L &amp;&amp; point.x &lt;= R &amp;&amp; point.y &gt;= T &amp;&amp; point.y &lt;= B;
}


function pointInAnyArtboard(point){
  return artboards.some(ab =&gt; pointInArtboard(ab, point));
}

function isArtboardGuideTarget(target){
  return !!(target &amp;&amp; (target.isArtboardBoard || target.isArtboardShadow || target.isArtboardBleed || target.isArtboardSafe));
}

function setArtboardsEditable(enabled){
  artboards.forEach(ab =&gt; {
    if (!ab?.board) return;
    ab.board.set({ selectable:!!enabled, evented:!!enabled });
    ab.board.hoverCursor = enabled ? 'move' : 'default';
    ab.board.setCoords();
  });
}

function pickArtboardForPoint(point){
  const candidates = artboards.filter(ab =&gt; pointInArtboard(ab, point));
  if (!candidates.length) return null;
  candidates.sort((a,b) =&gt; (a.w*a.h) - (b.w*b.h));
  return candidates[0];
}

function removeObjectFromArtboard(obj){
  artboards.forEach(ab =&gt; {
    const idx = ab.children.indexOf(obj.id);
    if (idx &gt;= 0) ab.children.splice(idx, 1);
  });
  obj.dataArtboardId = null;
}

function applyArtboardClipToChild(ab, obj){
  if (!ab || !obj) return;
  if (ab.clipContent) {
    obj.clipPath = new fabric.Rect({
      left:ab.board.left,
      top:ab.board.top,
      width:ab.w,
      height:ab.h,
      absolutePositioned:true
    });
    obj.__artboardClipManaged = true;
  } else if (obj.__artboardClipManaged) {
    obj.clipPath = null;
    obj.__artboardClipManaged = false;
  }
}

function refreshArtboardChildrenClipping(ab){
  if (!ab) return;
  (ab.children || []).forEach(id =&gt; {
    const obj = canvas.getObjects().find(o =&gt; o.id === id);
    if (!obj) return;
    applyArtboardClipToChild(ab, obj);
  });
}

function assignObjectToArtboard(obj, nextArtboard){
  if (!obj || isGuide(obj) || obj.isBezierEditorControl || obj.isBezierOverlay || obj.isArtboardBoard) return;
  const prev = getArtboardById(obj.dataArtboardId);
  if (prev &amp;&amp; prev.id === nextArtboard?.id) {
    applyArtboardClipToChild(prev, obj);
    return;
  }
  removeObjectFromArtboard(obj);
  if (!nextArtboard) {
    if (obj.__artboardClipManaged) {
      obj.clipPath = null;
      obj.__artboardClipManaged = false;
    }
    return;
  }
  if (!nextArtboard.children.includes(obj.id)) nextArtboard.children.push(obj.id);
  obj.dataArtboardId = nextArtboard.id;
  applyArtboardClipToChild(nextArtboard, obj);
}

function syncObjectArtboardMembership(obj){
  if (!obj || isGuide(obj) || obj.isBezierEditorControl || obj.isBezierOverlay || obj.isArtboardBoard) return;
  const b = obj.getBoundingRect(true, true);
  const center = { x:b.left + b.width/2, y:b.top + b.height/2 };
  const target = pickArtboardForPoint(center);
  assignObjectToArtboard(obj, target);
}

function syncArtboardAuxGeometry(ab){
  if (!ab) return;
  const left = ab.board.left;
  const top = ab.board.top;
  ab.w = Math.max(1, ab.board.getScaledWidth());
  ab.h = Math.max(1, ab.board.getScaledHeight());
  ab.board.set({ scaleX:1, scaleY:1, width:ab.w, height:ab.h });
  ab.shadow.set({ left:left+6, top:top+8, width:ab.w, height:ab.h });
  ab.bleed.set({ left:left-GUIDES.bleed, top:top-GUIDES.bleed, width:ab.w+2*GUIDES.bleed, height:ab.h+2*GUIDES.bleed });
  ab.safe.set({ left:left+GUIDES.safe, top:top+GUIDES.safe, width:ab.w-2*GUIDES.safe, height:ab.h-2*GUIDES.safe });
  [ab.board, ab.shadow, ab.bleed, ab.safe].forEach(o =&gt; o.setCoords());
}

function applyArtboardVisualState(ab){
  if (!ab) return;
  const bg = ab.background || {};
  const fill = bg.enabled ? (bg.color || '#ffffff') : 'rgba(0,0,0,0)';
  ab.board.set({
    fill,
    stroke:'rgba(0,0,0,.18)',
    strokeWidth:1,
    selectable:!!artboardMode,
    evented:!!artboardMode,
    lockRotation:true,
    hasControls:true,
    hasBorders:true,
    excludeFromExport: !ab.exportEnabled,
    opacity:1
  });
  ab.bleed.set({ visible: !!artboardMode });
  ab.safe.set({ visible: !!artboardMode });
  refreshArtboardChildrenClipping(ab);
}

function createArtboard(left = -docW/2, top = -docH/2, w = docW, h = docH) {
  const id = 'ab_' + Math.random().toString(36).slice(2, 9);
  const shadow = new fabric.Rect({
    left:left+6, top:top+8, width:w, height:h,
    fill:'rgba(0,0,0,0)', rx:2, ry:2,
    selectable:false, evented:false, excludeFromExport:true,
    opacity:0
  });
  const board = new fabric.Rect({
    left, top, width:w, height:h,
    fill:'#ffffff', stroke:'rgba(0,0,0,.15)', strokeWidth:1,
    rx:2, ry:2, selectable:true, evented:true, excludeFromExport:false,
    lockRotation:true
  });
  board.isArtboardBoard = true;
  shadow.isArtboardShadow = true;
  board.artboardId = id;
  board.dataName = `Artboard ${artboards.length + 1}`;

  const bleed = new fabric.Rect({
    left:left-GUIDES.bleed, top:top-GUIDES.bleed, width:w+2*GUIDES.bleed, height:h+2*GUIDES.bleed,
    fill:'transparent', stroke:'rgba(241,58,161,.5)', strokeDashArray:[6,6], strokeWidth:1,
    selectable:false, evented:false, excludeFromExport:true, opacity: GUIDES.bleed &gt; 0 ? 1 : 0
  });
  const safe = new fabric.Rect({
    left:left+GUIDES.safe, top:top+GUIDES.safe, width:w-2*GUIDES.safe, height:h-2*GUIDES.safe,
    fill:'transparent', stroke:'rgba(59,109,243,.5)', strokeDashArray:[6,6], strokeWidth:1,
    selectable:false, evented:false, excludeFromExport:true
  });
  bleed.isArtboardBleed = true;
  safe.isArtboardSafe = true;
  const bundle = {
    id,
    w,
    h,
    board,
    shadow,
    bleed,
    safe,
    clipContent:false,
    exportEnabled:true,
    background:{ enabled:true, color:'#FFFFFF', locked:true, includeInExport:true },
    children:[]
  };
  artboards.push(bundle);
  canvas.add(shadow, board, bleed, safe);
  activeArtboardId = id;
  syncActiveArtboardRefs();
  syncArtboardAuxGeometry(bundle);
  applyArtboardVisualState(bundle);
  orderArtboard();
  return bundle;
}

function ensureArtboard() {
  if (artboards.length) return;
  createArtboard();
  positionArtboard();
}

function addAdjacentArtboard(dir) {
  const current = getActiveArtboard();
  if (!current) return;
  const left = current.board.left;
  const top = current.board.top;
  let nextLeft = left;
  let nextTop = top;
  if (dir === 'right') nextLeft = left + current.w + ART_GAP;
  if (dir === 'left') nextLeft = left - current.w - ART_GAP;
  if (dir === 'bottom') nextTop = top + current.h + ART_GAP;
  if (dir === 'top') nextTop = top - current.h - ART_GAP;
  createArtboard(nextLeft, nextTop, current.w, current.h);
  fitToArtboard();
  updateArtboardPlusUI();
}

function orderArtboard() {
  artboards.forEach(a =&gt; {
    if (a.shadow) canvas.sendToBack(a.shadow);
    if (a.board) canvas.sendToBack(a.board);
    if (a.bleed) canvas.bringToFront(a.bleed);
    if (a.safe) canvas.bringToFront(a.safe);
  });
  canvas.getObjects().forEach(o =&gt; {
    if (!isGuide(o) &amp;&amp; !o.isBezierEditorControl &amp;&amp; !o.isBezierOverlay) canvas.bringToFront(o);
  });
}

function positionArtboard() {
  const current = getActiveArtboard();
  if (!current) return;
  current.w = docW;
  current.h = docH;
  current.board.set({ width:docW, height:docH });
  syncArtboardAuxGeometry(current);
  syncActiveArtboardRefs();
  canvas.requestRenderAll();
  updateArtboardPlusUI();
}

function fitToArtboard() {
  if (!artboard) return;
  const current = getActiveArtboard();
  const w = current?.w || docW;
  const h = current?.h || docH;
  const pad = 100;
  const cw = canvas.getWidth(), ch = canvas.getHeight();
  const newZoom = clamp(Math.min((cw-pad)/w, (ch-pad)/h), 0.05, 6);
  const artCx = artboard.left + w/2;
  const artCy = artboard.top + h/2;
  canvas.setViewportTransform([newZoom, 0, 0, newZoom, cw/2 - artCx*newZoom, ch/2 - artCy*newZoom]);
  zoom = newZoom;
  updateZoomLabel();
  updateArtboardPlusUI();
}

function setArtboardSize(w, h) {
  docW = clamp(w, 200, 5000);
  docH = clamp(h, 200, 5000);
  if ($('abW')) $('abW').value = String(Math.round(docW));
  if ($('abH')) $('abH').value = String(Math.round(docH));
  if (!artboard) ensureArtboard();
  positionArtboard();
  fitToArtboard();
}

function updateArtboardPlusUI() {
  const ui = $('artboardPlusUI');
  if (!ui) return;
  const current = getActiveArtboard();
  if (!artboardMode || !current || !current.board) {
    ui.style.display = 'none';
    return;
  }
  const vpt = canvas.viewportTransform || [1,0,0,1,0,0];
  const x1 = current.board.left * vpt[0] + vpt[4];
  const y1 = current.board.top * vpt[3] + vpt[5];
  const x2 = (current.board.left + current.w) * vpt[0] + vpt[4];
  const y2 = (current.board.top + current.h) * vpt[3] + vpt[5];
  const m = 16;
  $('btnAddArtTop').style.left = ((x1+x2)/2 - 14) + 'px';
  $('btnAddArtTop').style.top = (y1 - m - 14) + 'px';
  $('btnAddArtBottom').style.left = ((x1+x2)/2 - 14) + 'px';
  $('btnAddArtBottom').style.top = (y2 + m - 14) + 'px';
  $('btnAddArtLeft').style.left = (x1 - m - 14) + 'px';
  $('btnAddArtLeft').style.top = ((y1+y2)/2 - 14) + 'px';
  $('btnAddArtRight').style.left = (x2 + m - 14) + 'px';
  $('btnAddArtRight').style.top = ((y1+y2)/2 - 14) + 'px';
  ui.style.display = 'block';
}

let draggingArtboardId = null;

function refreshArtboardList(){
  const list = $('artboardList');
  const artCount = $('artboardCount');
  if (!list) return;
  if (artCount) artCount.textContent = artboards.length;
  list.innerHTML = '';
  if (!artboards.length) {
    list.innerHTML = '<div class="layer-empty" style="padding:10px 0">Sem artboards</div>';
    return;
  }
  artboards.forEach((ab, i) => {
    const item = document.createElement('div');
    item.className = 'artboard-item' + (ab.id === activeArtboardId ? ' active' : '');
    item.draggable = true;
    item.dataset.abid = ab.id;
    item.innerHTML = `<span class="artboard-name">${ab.board?.dataName || `Artboard ${i+1}`}</span><span class="artboard-size">${Math.round(ab.w)}×${Math.round(ab.h)}</span>`;
    item.addEventListener('click', () => {
      activeArtboardId = ab.id;
      syncActiveArtboardRefs();
      canvas.setActiveObject(ab.board);
      canvas.requestRenderAll();
      refreshArtboardList();
    });
    item.addEventListener('dragstart', () => { draggingArtboardId = ab.id; });
    item.addEventListener('dragover', e => e.preventDefault());
    item.addEventListener('drop', e => {
      e.preventDefault();
      if (!draggingArtboardId || draggingArtboardId === ab.id) return;
      const from = artboards.findIndex(x => x.id === draggingArtboardId);
      const to = artboards.findIndex(x => x.id === ab.id);
      if (from < 0 || to < 0) return;
      const [moved] = artboards.splice(from, 1);
      artboards.splice(to, 0, moved);
      orderArtboard();
      refreshArtboardList();
      canvas.requestRenderAll();
    });
    list.appendChild(item);
  });
}

function refreshArtboardInspector(){
  const current = getActiveArtboard();
  const clip = $('abClipContent');
  const exp = $('abExportEnabled');
  const bgEn = $('abBgEnabled');
  const bgColor = $('abBgColor');
  const bgLock = $('abBgLock');
  const bgExp = $('abBgExport');
  const abW = $('abW');
  const abH = $('abH');
  refreshArtboardList();
  if (!clip || !current) return;
  clip.checked = !!current.clipContent;
  exp.checked = !!current.exportEnabled;
  bgEn.checked = !!current.background?.enabled;
  bgColor.value = current.background?.color || '#FFFFFF';
  bgLock.checked = !!current.background?.locked;
  bgExp.checked = !!current.background?.includeInExport;
  bgColor.disabled = !!current.background?.locked;
  if (abW) abW.value = String(Math.round(current.w));
  if (abH) abH.value = String(Math.round(current.h));
}
function updateZoomLabel() {
  const pct = Math.round(zoom*100) + '%';
  const el = $('zoomLabel');
  if (el) el.textContent = pct;
  const top = $('zoomTopLabel');
  if (top) top.textContent = 'ZOOM ' + pct;
}

// ─── Pan / Zoom ──────────────────────────────────────────
canvas.on('mouse:wheel', opt =&gt; {
  const e = opt.e; e.preventDefault(); e.stopPropagation();
  const newZoom = clamp(zoom * Math.pow(0.999, e.deltaY), 0.05, 10);
  canvas.zoomToPoint(new fabric.Point(e.offsetX, e.offsetY), newZoom);
  zoom = newZoom; updateZoomLabel();
  updateArtboardPlusUI();
});

canvas.on('mouse:down', opt =&gt; {
  const e = opt.e;
  const target = opt.target;
  const pointer = canvas.getPointer(e);
  if (!artboardMode) {
    if (!pointInAnyArtboard(pointer)) setArtboardsEditable(true);
    else if (!target || isArtboardGuideTarget(target)) {
      setArtboardsEditable(false);
      if (canvas.getActiveObject() &amp;&amp; isArtboardGuideTarget(canvas.getActiveObject())) {
        canvas.discardActiveObject();
        canvas.requestRenderAll();
      }
    }
  }
  if (e.button === 1 || isSpaceDown) {
    isPanning = true; canvas.setCursor('grab');
    lastX = e.clientX; lastY = e.clientY;
    opt.e.preventDefault();
    return;
  }

  if (artboardMode &amp;&amp; e.button === 0 &amp;&amp; !target) {
    const pointer = canvas.getPointer(e);
    artboardCreateState.active = true;
    artboardCreateState.start = { x:pointer.x, y:pointer.y };
    artboardCreateState.ghost = new fabric.Rect({
      left:pointer.x, top:pointer.y, width:1, height:1,
      fill:'rgba(127,90,240,.08)', stroke:'rgba(127,90,240,.9)', strokeDashArray:[6,4],
      selectable:false, evented:false, excludeFromExport:true
    });
    canvas.add(artboardCreateState.ghost);
    canvas.requestRenderAll();
    return;
  }

  if (activeTool === 'bezier' || activeTool === 'bezier-v2') {
    if (isArtboardGuideTarget(target)) {
      canvas.discardActiveObject();
      canvas.requestRenderAll();
    }
    if (e.button !== 0) return;
    const pointer = canvas.getPointer(e);
    if (bezierEditor.enabled &amp;&amp; bezierEditor.path &amp;&amp; vectorToolState.mode !== 'creating') {
      if (target?.isBezierEditorControl) {
        const [role, idxStr] = String(target.bziRole || '').split('-');
        if (role === 'anchor') removePointAtIndex(bezierEditor.path, Number(idxStr));
        opt.e.preventDefault();
        return;
      }
      if (target === bezierEditor.path) {
        const seg = getNearestBezierSegment(bezierEditor.path, pointer);
        if (seg &gt;= 0) insertPointOnSegment(bezierEditor.path, seg);
        opt.e.preventDefault();
        return;
      }
    }
    if (vectorToolState.mode !== 'creating') startBezierCreation({ modelKey:getActiveBezierModelKey() });
    addBezierPoint(pointer, e);
    vectorToolState.dragStart = { x:pointer.x, y:pointer.y };
    vectorToolState.dragStarted = false;
    opt.e.preventDefault();
    return;
  }

  if (activeTool === 'text' &amp;&amp; (!opt.target || isGuide(opt.target))) {
    const p = canvas.getPointer(e);
    textDragStart = { x:p.x, y:p.y };
    textDragMoved = false;
    opt.e.preventDefault();
    return;
  }
});

canvas.on('mouse:move', opt =&gt; {
  if (isPanning) {
    const e = opt.e;
    const vpt = canvas.viewportTransform;
    vpt[4] += e.clientX - lastX;
    vpt[5] += e.clientY - lastY;
    canvas.setViewportTransform(vpt);
    lastX = e.clientX; lastY = e.clientY;
    updateArtboardPlusUI();
    return;
  }

  if (artboardCreateState.active &amp;&amp; artboardCreateState.start &amp;&amp; artboardCreateState.ghost) {
    const pointer = canvas.getPointer(opt.e);
    const sx = artboardCreateState.start.x;
    const sy = artboardCreateState.start.y;
    const left = Math.min(sx, pointer.x);
    const top = Math.min(sy, pointer.y);
    const width = Math.max(1, Math.abs(pointer.x - sx));
    const height = Math.max(1, Math.abs(pointer.y - sy));
    artboardCreateState.ghost.set({ left, top, width, height });
    artboardCreateState.ghost.setCoords();
    canvas.requestRenderAll();
    return;
  }

  if ((activeTool === 'bezier' || activeTool === 'bezier-v2') &amp;&amp; vectorToolState.mode === 'creating') {
    const pointer = canvas.getPointer(opt.e);
    if (vectorToolState.dragPointIndex &gt;= 0 &amp;&amp; (opt.e.buttons &amp; 1)) {
      updateDraggedCreatePoint(pointer, opt.e);
    } else {
      updateBezierCreationPreview(pointer);
    }
    return;
  }

  if (vectorToolState.pathDrag &amp;&amp; bezierEditor.enabled &amp;&amp; bezierEditor.path) {
    const pointer = canvas.getPointer(opt.e);
    const drag = vectorToolState.pathDrag;
    const dx = pointer.x - drag.last.x;
    const dy = pointer.y - drag.last.y;
    drag.last = pointer;
    const m = ensurePathVectorModel(bezierEditor.path);
    if (!m) return;
    m.points.forEach(pt =&gt; {
      pt.x += dx; pt.y += dy;
      pt.inX += dx; pt.inY += dy;
      pt.outX += dx; pt.outY += dy;
    });
    applyVectorModelToPath(bezierEditor.path, bezierEditor.modelKey);
    refreshBezierEditorControls();
    return;
  }

  if (vectorToolState.segmentDrag &amp;&amp; bezierEditor.enabled &amp;&amp; bezierEditor.path) {
    const pointer = canvas.getPointer(opt.e);
    const drag = vectorToolState.segmentDrag;
    const dx = pointer.x - drag.last.x;
    const dy = pointer.y - drag.last.y;
    drag.last = pointer;
    const m = ensurePathVectorModel(bezierEditor.path);
    if (!m) return;
    const i0 = drag.seg;
    const i1 = (i0 + 1) % m.points.length;
    const p0 = m.points[i0], p1 = m.points[i1];
    p0.outX += dx; p0.outY += dy;
    p1.inX += dx; p1.inY += dy;
    applyVectorModelToPath(bezierEditor.path, bezierEditor.modelKey);
    refreshBezierEditorControls();
    return;
  }

  if ((activeTool === 'bezier' || activeTool === 'bezier-v2') &amp;&amp; bezierEditor.enabled &amp;&amp; bezierEditor.path &amp;&amp; vectorToolState.mode !== 'creating') {
    const t = opt.target;
    if (t?.isBezierEditorControl &amp;&amp; String(t.bziRole || '').startsWith('anchor-')) canvas.defaultCursor = 'not-allowed';
    else if (t === bezierEditor.path) canvas.defaultCursor = 'copy';
    else canvas.defaultCursor = 'crosshair';
    return;
  }

  const clickProbe = vectorToolState.clickProbe;
  if (clickProbe &amp;&amp; !clickProbe.moved) {
    const pointer = canvas.getPointer(opt.e);
    if (Math.hypot(pointer.x - clickProbe.x, pointer.y - clickProbe.y) &gt; vectorToolState.clickMovePx) clickProbe.moved = true;
  }

  if (activeTool === 'text' &amp;&amp; textDragStart) {
    const p = canvas.getPointer(opt.e);
    textDragMoved = Math.hypot(p.x - textDragStart.x, p.y - textDragStart.y) &gt; 8;
  }
});

canvas.on('mouse:up', opt =&gt; {
  if (isPanning) { isPanning = false; canvas.setCursor(activeTool==='text' ? 'text' : 'default'); }

  if (artboardCreateState.active) {
    const ghost = artboardCreateState.ghost;
    const start = artboardCreateState.start;
    const pointer = canvas.getPointer(opt.e);
    const left = Math.min(start?.x || pointer.x, pointer.x);
    const top = Math.min(start?.y || pointer.y, pointer.y);
    const width = Math.abs(pointer.x - (start?.x || pointer.x));
    const height = Math.abs(pointer.y - (start?.y || pointer.y));
    if (ghost &amp;&amp; canvas.getObjects().includes(ghost)) canvas.remove(ghost);
    artboardCreateState.active = false;
    artboardCreateState.start = null;
    artboardCreateState.ghost = null;
    if (width &gt;= 24 &amp;&amp; height &gt;= 24) {
      createArtboard(left, top, width, height);
      setStatus('Artboard criado por arrasto.');
    }
    canvas.requestRenderAll();
    return;
  }

  if ((activeTool === 'bezier' || activeTool === 'bezier-v2') &amp;&amp; vectorToolState.mode === 'creating') {
    const i = vectorToolState.dragPointIndex;
    if (i &gt;= 0 &amp;&amp; !vectorToolState.dragStarted &amp;&amp; !vectorToolState.pendingClose) resetCreatePointToCorner(vectorToolState.points[i]);
    vectorToolState.dragPointIndex = -1;
    vectorToolState.dragStart = null;
    vectorToolState.dragStarted = false;
    updateBezierCreationPreview();
    finalizeBezierPendingClose();
  }

  if (vectorToolState.pathDrag) {
    vectorToolState.pathDrag = null;
    snapshot();
  }

  if (vectorToolState.segmentDrag) {
    vectorToolState.segmentDrag = null;
    snapshot();
  }

  if (activeTool === 'text' &amp;&amp; textDragStart) {
    const pointer = canvas.getPointer(opt.e);
    const dx = pointer.x - textDragStart.x;
    const dy = pointer.y - textDragStart.y;
    if (!textDragMoved || Math.hypot(dx, dy) &lt; 8) {
      addArtTextAt(pointer.x, pointer.y);
    } else {
      addTextBoxAt(Math.min(textDragStart.x, pointer.x), Math.min(textDragStart.y, pointer.y), Math.abs(dx), Math.abs(dy));
    }
    textDragStart = null;
    textDragMoved = false;
    setActiveTool('select');
  }
});
canvas.on('mouse:down', opt =&gt; {
  const target = opt.target;
  if (!target) return;
  const ab = artboards.find(a =&gt; a.board === target || a.shadow === target || a.bleed === target || a.safe === target);
  if (!ab) return;
  activeArtboardId = ab.id;
  syncActiveArtboardRefs();
  updateArtboardPlusUI();
  setStatus('Prancheta ativa selecionada');
});


canvas.on('mouse:down', opt =&gt; {
  if (activeTool !== 'direct-select' &amp;&amp; activeTool !== 'select') return;
  if (opt.e?.button !== 0) return;
  const pointer = canvas.getPointer(opt.e);
  vectorToolState.clickProbe = {
    target: opt.target || null,
    x: pointer.x,
    y: pointer.y,
    moved: false,
    at: performance.now()
  };

  if (activeTool !== 'direct-select') return;

  const target = opt.target;
  if (!target) {
    if (bezierEditor.enabled) finalizeBezierEditor();
    vectorToolState.pendingEditTarget = null;
    vectorToolState.pendingEditAt = 0;
    vectorToolState.pendingStateTarget = null;
    vectorToolState.pendingStateCount = 0;
    vectorToolState.pendingStateMode = '';
    vectorToolState.outsideClickPendingAt = 0;
    vectorToolState.outsideClickPendingCount = 0;
    vectorToolState.clickPending = { target:null, at:0, count:0 };
    canvas.discardActiveObject();
    if (activeTool !== 'select') setActiveTool('select');
    setInteractionState('idle');
    canvas.requestRenderAll();
    return;
  }

  if (!pathIsBezierEditable(target)) {
    if (bezierEditor.enabled) finalizeBezierEditor();
    vectorToolState.clickPending = { target:null, at:0, count:0 };
    return;
  }

  if (!bezierEditor.enabled || bezierEditor.path !== target) {
    if (bezierEditor.enabled &amp;&amp; bezierEditor.path !== target) finalizeBezierEditor();
    const editableTarget = convertVectorShapeToBezierPath(target, resolveBezierModelKey(target));
    canvas.setActiveObject(editableTarget);
    attachBezierEditor(editableTarget, { handlesActive:true, modelKey:resolveBezierModelKey(editableTarget) });
    return;
  }

  if (bezierEditor.handlesActive) {
    vectorToolState.pathDrag = { last:pointer };
    vectorToolState.mode = 'transforming';
    return;
  }

  const seg = getNearestBezierSegment(target, pointer);
  if (seg &gt;= 0 &amp;&amp; !opt.e.altKey) {
    vectorToolState.segmentDrag = { seg, last:pointer };
    vectorToolState.mode = 'transforming';
  }
});

canvas.on('mouse:up', opt =&gt; {
  if (activeTool !== 'select') return;
  if (opt.e?.button !== 0) return;
  const clickProbe = vectorToolState.clickProbe;
  vectorToolState.clickProbe = null;
  if (!clickProbe || clickProbe.moved) return;

  const target = opt.target || clickProbe.target;

  if (bezierEditor.enabled &amp;&amp; target?.isBezierEditorControl) {
    setInteractionState(bezierEditor.handlesActive ? 'edit-handles' : 'edit');
    return;
  }

  const now = performance.now();
  const resetPending = () =&gt; {
    vectorToolState.pendingEditTarget = null;
    vectorToolState.pendingEditAt = 0;
    vectorToolState.pendingStateTarget = null;
    vectorToolState.pendingStateCount = 0;
    vectorToolState.pendingStateMode = '';
    vectorToolState.outsideClickPendingAt = 0;
    vectorToolState.outsideClickPendingCount = 0;
    vectorToolState.clickPending = { target:null, at:0, count:0 };
  };

  if (!target) {
    if (bezierEditor.enabled && bezierEditor.handlesActive) {
      const elapsed = now - Number(vectorToolState.outsideClickPendingAt || 0);
      vectorToolState.outsideClickPendingCount = elapsed <= vectorToolState.doubleClickMs
        ? (Number(vectorToolState.outsideClickPendingCount || 0) + 1)
        : 1;
      vectorToolState.outsideClickPendingAt = now;
      if (vectorToolState.outsideClickPendingCount < 2) {
        setStatus('Dê 2 cliques fora da forma para sair da edição com alças.');
        setInteractionState('edit-handles');
        return;
      }
    }
    if (bezierEditor.enabled) finalizeBezierEditor();
    resetPending();
    canvas.discardActiveObject();
    setInteractionState('idle');
    canvas.requestRenderAll();
    return;
  }

  if (!pathIsBezierEditable(target)) {
    vectorToolState.clickPending = { target:null, at:0, count:0 };
    vectorToolState.outsideClickPendingAt = 0;
    vectorToolState.outsideClickPendingCount = 0;
    if (bezierEditor.enabled) finalizeBezierEditor();
    return;
  }

  vectorToolState.outsideClickPendingAt = 0;
  vectorToolState.outsideClickPendingCount = 0;

  const pending = vectorToolState.clickPending || { target:null, at:0, count:0 };
  const isSameTarget = pending.target === target;
  const within = (now - Number(pending.at || 0)) &lt;= vectorToolState.doubleClickMs;
  const isDoubleClick = isSameTarget &amp;&amp; within &amp;&amp; pending.count &gt;= 1;

  if (isDoubleClick) vectorToolState.clickPending = { target, at: now, count: 0 };
  else vectorToolState.clickPending = { target, at: now, count: 1 };

  if (!bezierEditor.enabled || bezierEditor.path !== target) {
    if (bezierEditor.enabled &amp;&amp; bezierEditor.path !== target) finalizeBezierEditor();
    const editableTarget = convertVectorShapeToBezierPath(target, resolveBezierModelKey(target));
    canvas.setActiveObject(editableTarget);
    vectorToolState.pendingEditTarget = editableTarget;
    vectorToolState.pendingEditAt = now;
    vectorToolState.pendingStateTarget = editableTarget;
    vectorToolState.pendingStateCount = 0;
    vectorToolState.pendingStateMode = 'to-edit';
    if (isDoubleClick) {
      attachBezierEditor(editableTarget, { handlesActive:false, modelKey:resolveBezierModelKey(editableTarget) });
      vectorToolState.pendingStateMode = 'to-handles';
    } else {
      setInteractionState('selection');
    }
    return;
  }

  vectorToolState.pendingEditAt = now;
  vectorToolState.pendingStateTarget = target;
  vectorToolState.pendingStateCount = 0;

  if (!isDoubleClick) {
    setInteractionState(bezierEditor.handlesActive ? 'edit-handles' : 'edit');
    return;
  }

  if (!bezierEditor.handlesActive) {
    vectorToolState.pendingStateMode = 'to-handles';
    bezierEditor.handlesActive = true;
    setInteractionState('edit-handles');
    refreshBezierEditorControls();
    return;
  }

  vectorToolState.pendingStateMode = 'to-select';
  finalizeBezierEditor();
});

canvas.on('mouse:dblclick', opt =&gt; {
  const target = opt.target;
  const pointer = canvas.getPointer(opt.e);
  if (!target) {
    if (bezierEditor.enabled) {
      finalizeBezierEditor();
      setActiveTool('select');
    }
    return;
  }
  if ((activeTool === 'bezier' || activeTool === 'bezier-v2') &amp;&amp; vectorToolState.mode === 'creating') {
    const path = finishBezierCreation({toEditing:false});
    if (path) {
      canvas.setActiveObject(path);
      setActiveTool('select');
    }
    return;
  }
  if (target.isBezierEditorControl) {
    const [role, idxStr] = String(target.bziRole || '').split('-');
    if (role === 'anchor' &amp;&amp; bezierEditor.path &amp;&amp; bezierEditor.enabled &amp;&amp; (activeTool === 'bezier' || activeTool === 'bezier-v2')) {
      removePointAtIndex(bezierEditor.path, Number(idxStr));
    }
    return;
  }
  if (pathIsBezierEditable(target)) {
    if (!bezierEditor.enabled || bezierEditor.path !== target) {
      if (activeTool === 'direct-select') {
        const editableTarget = convertVectorShapeToBezierPath(target, resolveBezierModelKey(target));
        attachBezierEditor(editableTarget, { handlesActive:true, modelKey:resolveBezierModelKey(editableTarget) });
      }
      return;
    }
    if (activeTool === 'bezier' || activeTool === 'bezier-v2') {
      const seg = getNearestBezierSegment(target, pointer);
      if (seg &gt;= 0) insertPointOnSegment(target, seg);
    }
    return;
  }
});

window.addEventListener('keydown', e =&gt; {
  if ((activeTool === 'bezier' || activeTool === 'bezier-v2') &amp;&amp; vectorToolState.mode === 'creating') {
    if ((e.metaKey||e.ctrlKey) &amp;&amp; e.key.toLowerCase() === 'z') {
      e.preventDefault();
      if (undoBezierCreationAndFinalize()) return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      const path = finishBezierCreation({toEditing:false});
      if (path) {
        canvas.setActiveObject(path);
        setActiveTool('select');
      }
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      cancelBezierCreationStep();
      return;
    }
  }
  if (activeTool === 'direct-select' &amp;&amp; e.key === 'Escape' &amp;&amp; bezierEditor.enabled) {
    e.preventDefault();
    finalizeBezierEditor();
    setActiveTool('select');
    return;
  }
  if (e.code === 'Space' &amp;&amp; !e.target.matches('input,textarea,select') &amp;&amp; !isSpaceDown) {
    isSpaceDown = true; canvas.setCursor('grab'); e.preventDefault();
  }
  if ((e.metaKey||e.ctrlKey) &amp;&amp; e.key === 'z') { e.preventDefault(); undo(); }
  if ((e.metaKey||e.ctrlKey) &amp;&amp; e.key === 'y') { e.preventDefault(); redo(); }
  if ((e.metaKey||e.ctrlKey) &amp;&amp; e.key === 'd') { e.preventDefault(); duplicate(); }
  if ((e.metaKey||e.ctrlKey) &amp;&amp; !e.shiftKey &amp;&amp; e.key.toLowerCase()==='g') { e.preventDefault(); groupSelection(); }
  if ((e.metaKey||e.ctrlKey) &amp;&amp; e.shiftKey &amp;&amp; e.key.toLowerCase()==='g') { e.preventDefault(); ungroupSelection(); }
  if ((e.metaKey||e.ctrlKey) &amp;&amp; e.shiftKey &amp;&amp; e.key === ']') { e.preventDefault(); bringForwardSelection(); }
  if ((e.metaKey||e.ctrlKey) &amp;&amp; e.shiftKey &amp;&amp; e.key === '[') { e.preventDefault(); sendBackwardSelection(); }
  if ((e.key === 'Delete' || e.key === 'Backspace') &amp;&amp; !e.target.matches('input,textarea')) { del(); }
}, {passive:false});

window.addEventListener('keyup', e =&gt; {
  if (e.code === 'Space') { isSpaceDown = false; canvas.setCursor('default'); }
});

window.addEventListener('keydown', e =&gt; {
  if (e.key === 'Alt') {
    isAltMeasureDown = true;
    refreshSmartMeasurementState();
    canvas.requestRenderAll();
  }
});

window.addEventListener('keyup', e =&gt; {
  if (e.key === 'Alt') {
    isAltMeasureDown = false;
    refreshSmartMeasurementState();
    canvas.requestRenderAll();
  }
});

// ─── Status text ─────────────────────────────────────────
function setStatus(txt) {
  const el = $('statusText'); if (el) el.textContent = txt;
}

// ─── Add objects ─────────────────────────────────────────
function addArtTextAt(left, top) {
  const t = new fabric.IText('Texto artístico', {
    left, top,
    fontFamily: 'Outfit', fontSize: 42,
    fill: '#111', editable: true
  });
  canvas.add(t); canvas.setActiveObject(t); canvas.requestRenderAll();
  setStatus('Texto artístico adicionado');
}

function addTextBoxAt(left, top, width=360, height=120) {
  const t = new fabric.Textbox('Caixa de texto', {
    left, top,
    width: Math.max(120, width),
    height: Math.max(48, height),
    fontFamily: 'Outfit', fontSize: 32,
    fill: '#111', editable: true,
    textAlign: 'left'
  });
  canvas.add(t); canvas.setActiveObject(t); canvas.requestRenderAll();
  setStatus('Caixa de texto adicionada');
}

function addArtText() {
  ensureArtboard();
  addArtTextAt(artboard.left + 60, artboard.top + 60);
}

function addTextBox() {
  ensureArtboard();
  addTextBoxAt(artboard.left + 60, artboard.top + 140, 360, 120);
}

function addRect() {
  ensureArtboard();
  const r = new fabric.Rect({
    left: artboard.left + 80, top: artboard.top + 140,
    width: 260, height: 160, rx:16, ry:16,
    fill: 'rgba(59,109,243,.15)', stroke: 'rgba(0,0,0,.1)', strokeWidth: 1
  });
  r.vectorModel = { points:[{x:r.left,y:r.top,inX:r.left,inY:r.top,outX:r.left,outY:r.top,kind:'corner'},{x:r.left+r.width,y:r.top,inX:r.left+r.width,inY:r.top,outX:r.left+r.width,outY:r.top,kind:'corner'},{x:r.left+r.width,y:r.top+r.height,inX:r.left+r.width,inY:r.top+r.height,outX:r.left+r.width,outY:r.top+r.height,kind:'corner'},{x:r.left,y:r.top+r.height,inX:r.left,inY:r.top+r.height,outX:r.left,outY:r.top+r.height,kind:'corner'}], closed:true };
  canvas.add(r); canvas.setActiveObject(r); canvas.requestRenderAll();
}

function addCircle() {
  ensureArtboard();
  const c = new fabric.Circle({
    left: artboard.left + 420, top: artboard.top + 160,
    radius: 80, fill:'rgba(127,90,240,.22)', stroke:'rgba(0,0,0,.1)', strokeWidth:1
  });
  const k=.5522847498, cx=c.left+c.radius, cy=c.top+c.radius, rr=c.radius;
  c.vectorModel = { points:[{x:cx+rr,y:cy,inX:cx+rr,inY:cy-k*rr,outX:cx+rr,outY:cy+k*rr,kind:'smooth'},{x:cx,y:cy+rr,inX:cx+k*rr,inY:cy+rr,outX:cx-k*rr,outY:cy+rr,kind:'smooth'},{x:cx-rr,y:cy,inX:cx-rr,inY:cy+k*rr,outX:cx-rr,outY:cy-k*rr,kind:'smooth'},{x:cx,y:cy-rr,inX:cx-k*rr,inY:cy-rr,outX:cx+k*rr,outY:cy-rr,kind:'smooth'}], closed:true };
  canvas.add(c); canvas.setActiveObject(c); canvas.requestRenderAll();
}

function addLine() {
  ensureArtboard();
  const l = new fabric.Line([artboard.left+80, artboard.top+docH-120, artboard.left+520, artboard.top+docH-120], {
    stroke:'rgba(0,0,0,.55)', strokeWidth:2
  });
  canvas.add(l); canvas.setActiveObject(l); canvas.requestRenderAll();
}

function addBezier() {
  setActiveTool('bezier');
  if (bezierEditor.enabled &amp;&amp; bezierEditor.path) {
    setInteractionState(bezierEditor.handlesActive ? 'edit-handles' : 'edit');
    ensureBezierNodePanel();
    return;
  }
  startBezierCreation({ modelKey:'vectorModel' });
}

function addBezierV2() {
  if (!ENABLE_BEZIER_V2) return addBezier();
  setActiveTool('bezier-v2');
  if (bezierEditor.enabled &amp;&amp; bezierEditor.path &amp;&amp; bezierEditor.modelKey === 'vectorModelV2') {
    setInteractionState(bezierEditor.handlesActive ? 'edit-handles' : 'edit');
    ensureBezierNodePanel();
    return;
  }
  startBezierCreation({ modelKey:'vectorModelV2' });
}

// ─── Bezier tool (Figma-like states) ─────────────────────
const vectorToolState = {
  mode: 'idle', // idle | creating | editing | transforming
  interaction: 'idle', // idle | selection | edit | edit-handles | creating
  points: [],
  closed: false,
  previewPath: null,
  dragPointIndex: -1,
  segmentDrag: null,
  dragStart: null,
  dragStarted: false,
  pendingClose: false,
  lastPointAddedAt: 0,
  lastPointAddedPos: null,
  modelKey: 'vectorModel',
  pendingEditTarget: null,
  pendingEditAt: 0,
  pendingStateTarget: null,
  pendingStateCount: 0,
  pendingStateMode: '',
  outsideClickPendingAt: 0,
  outsideClickPendingCount: 0,
  pathDrag: null,
  clickPending: { target:null, at:0, count:0 },
  clickProbe: null,
  doubleClickMs: 350,
  clickMovePx: 4
};

const bezierEditor = {
  path: null,
  controls: [],
  links: [],
  enabled: false,
  handlesActive: false,
  modelKey: 'vectorModel',
  selectedAnchors: [],
  selectionFrame: null
};

const BEZIER_CREATE_HIT = 12;

function setInteractionState(state){
  vectorToolState.interaction = state;
  const labels = {
    'idle': 'Sem seleção.',
    'selection': 'Modo seleção/transformação ativo (1 clique). Dê 2 cliques para editar.',
    'edit': 'Modo edição de pontos ativo. Dê 2 cliques na forma para mostrar alças.',
    'edit-handles': 'Modo edição com alças ativas. Dê 2 cliques para voltar ao transformar.',
    'creating': (vectorToolState.modelKey === 'vectorModelV2' ? 'Bézier V2: criação suave ativa (anti-duplo-clique reduzido). Enter finaliza, Esc desfaz.' : 'Vetor: clique para ponto reto, arraste para alças. Enter finaliza, Esc desfaz.')
  };
  if (labels[state]) setStatus(labels[state]);
}

function getActiveBezierModelKey(){
  return activeTool === 'bezier-v2' ? 'vectorModelV2' : 'vectorModel';
}

function resolveBezierModelKey(pathObj, fallback=getActiveBezierModelKey()){
  if (pathObj?.vectorModelV2?.points?.length) return 'vectorModelV2';
  if (pathObj?.vectorModel?.points?.length) return 'vectorModel';
  return fallback;
}

function makeBezierPoint(x, y) {

  return { x, y, inX:x, inY:y, outX:x, outY:y, kind:'corner' };
}

function cloneBezierPoints(points=[]) {
  return points.map(p =&gt; ({...p}));
}


function normalizeBezierPointKind(pt){
  if (!pt) return;
  if (!pt.kind) pt.kind = 'corner';
  if (typeof pt.broken !== 'boolean') pt.broken = pt.kind === 'corner';
}

function inferAnchorDisplayType(pt){
  if (!pt) return 'corner';
  if (pt.kind === 'mirrored') return 'mirrored';
  if (pt.kind === 'smooth') return 'smooth';
  return 'corner';
}

function ensureBezierNodePanel(){
  const panel = $('vectorNodePanel');
  const hint = $('vectorNodeHint');
  const controls = $('vectorNodeControls');
  if (!panel || !hint || !controls) return;

  const activePath = bezierEditor.enabled ? bezierEditor.path : activeObj();
  const canShow = activeTool === 'direct-select' &amp;&amp; pathIsBezierEditable(activePath);
  panel.style.display = canShow ? 'block' : 'none';
  if (!canShow) return;

  const m = ensurePathVectorModel(activePath);
  const selected = (bezierEditor.selectedAnchors || []).filter(i =&gt; m?.points?.[i]);
  const hasSelection = !!selected.length;

  hint.style.display = hasSelection ? 'none' : 'block';
  controls.style.display = hasSelection ? 'block' : 'none';
  if (!hasSelection) {
    $('btnNodeCorner')?.classList.remove('active');
    $('btnNodeSmooth')?.classList.remove('active');
    $('btnNodeMirrored')?.classList.remove('active');
    if ($('btnNodeBreak')) $('btnNodeBreak').textContent = 'Quebrar alças';
    return;
  }

  const first = m.points[selected[0]];
  const mixedType = selected.some(i =&gt; inferAnchorDisplayType(m.points[i]) !== inferAnchorDisplayType(first));
  const mixedBreak = selected.some(i =&gt; !!m.points[i].broken !== !!first.broken);
  const type = mixedType ? '' : inferAnchorDisplayType(first);
  $('btnNodeCorner')?.classList.toggle('active', type === 'corner');
  $('btnNodeSmooth')?.classList.toggle('active', type === 'smooth');
  $('btnNodeMirrored')?.classList.toggle('active', type === 'mirrored');
  if ($('btnNodeBreak')) $('btnNodeBreak').textContent = (mixedBreak || !first.broken) ? 'Quebrar alças' : 'Religar alças';
}

function selectBezierAnchorIndices(indices=[]){
  bezierEditor.selectedAnchors = Array.from(new Set(indices.filter(Number.isFinite)));
  const selected = new Set(bezierEditor.selectedAnchors);
  bezierEditor.controls.forEach(ctrl =&gt; {
    const [role, idxStr] = String(ctrl.bziRole).split('-');
    const idx = Number(idxStr);
    const on = selected.has(idx);
    if (role === 'anchor') {
      ctrl.set({ fill: on ? '#2f9bff' : '#ffffff', stroke:'#2f9bff', strokeWidth: on ? 2.4 : 2 });
      return;
    }
    if (role === 'in' || role === 'out') {
      ctrl.set({ fill:'#ffffff', stroke: on ? '#2f9bff' : 'rgba(47,155,255,.7)', strokeWidth: on ? 1.8 : 1.3, opacity:on ? 1 : .82 });
    }
  });
  ensureBezierNodePanel();
  refreshBezierSelectionFrame(activeObj());
  canvas.requestRenderAll();
}

function applyAnchorCoupling(pt, role, dx, dy){
  if (!pt || pt.broken || pt.kind === 'corner') return;
  const movedLen = Math.hypot(dx, dy) || 1;
  if (role === 'in') {
    if (pt.kind === 'mirrored') {
      pt.outX = pt.x - dx; pt.outY = pt.y - dy;
      return;
    }
    const outLen = Math.hypot(pt.outX - pt.x, pt.outY - pt.y) || movedLen;
    pt.outX = pt.x - (dx / movedLen) * outLen;
    pt.outY = pt.y - (dy / movedLen) * outLen;
    return;
  }
  if (role === 'out') {
    if (pt.kind === 'mirrored') {
      pt.inX = pt.x - dx; pt.inY = pt.y - dy;
      return;
    }
    const inLen = Math.hypot(pt.inX - pt.x, pt.inY - pt.y) || movedLen;
    pt.inX = pt.x - (dx / movedLen) * inLen;
    pt.inY = pt.y - (dy / movedLen) * inLen;
  }
}

function applySelectedNodeType(type){
  if (!bezierEditor.path) return;
  const m = ensurePathVectorModel(bezierEditor.path);
  const selected = (bezierEditor.selectedAnchors || []).filter(i =&gt; m?.points?.[i]);
  if (!selected.length) return;
  selected.forEach(i =&gt; {
    const pt = m.points[i];
    normalizeBezierPointKind(pt);
    if (type === 'corner') {
      pt.kind = 'corner';
      pt.broken = true;
      return;
    }
    pt.kind = type === 'mirrored' ? 'mirrored' : 'smooth';
    pt.broken = false;
  });
  applyVectorModelToPath(bezierEditor.path, bezierEditor.modelKey);
  refreshBezierEditorControls();
  snapshot();
}

function toggleSelectedNodeBreak(){
  if (!bezierEditor.path) return;
  const m = ensurePathVectorModel(bezierEditor.path);
  const selected = (bezierEditor.selectedAnchors || []).filter(i =&gt; m?.points?.[i]);
  if (!selected.length) return;
  const allBroken = selected.every(i =&gt; !!m.points[i].broken);
  selected.forEach(i =&gt; {
    const pt = m.points[i];
    normalizeBezierPointKind(pt);
    if (allBroken) {
      pt.broken = false;
      if (pt.kind === 'corner') pt.kind = 'smooth';
    } else {
      pt.broken = true;
    }
  });
  applyVectorModelToPath(bezierEditor.path, bezierEditor.modelKey);
  refreshBezierEditorControls();
  snapshot();
}

function normalizeVectorByShift(dx, dy, stepDeg=15){
  const ang = Math.atan2(dy, dx);
  const len = Math.hypot(dx, dy);
  const step = (Math.PI/180) * stepDeg;
  const a = Math.round(ang / step) * step;
  return { dx: Math.cos(a) * len, dy: Math.sin(a) * len };
}

function parsePathDataSafe(pathData){
  if (fabric?.util?.parsePath) return fabric.util.parsePath(pathData);
  return new fabric.Path(pathData).path;
}

function bezierPointsToPathData(points, closed=false){
  if (!points || points.length &lt; 2) return '';
  const segs = [`M ${points[0].x} ${points[0].y}`];
  for (let i=1;i&lt;points.length;i++) {
    const prev = points[i-1];
    const curr = points[i];
    segs.push(`C ${prev.outX} ${prev.outY}, ${curr.inX} ${curr.inY}, ${curr.x} ${curr.y}`);
  }
  if (closed &amp;&amp; points.length &gt; 2) {
    const last = points[points.length-1];
    const first = points[0];
    segs.push(`C ${last.outX} ${last.outY}, ${first.inX} ${first.inY}, ${first.x} ${first.y} Z`);
  }
  return segs.join(' ');
}

function bezierPointsToPathCommands(points, closed=false){
  if (!points || points.length &lt; 2) return [];
  const commands = [['M', points[0].x, points[0].y]];
  for (let i=1;i&lt;points.length;i++) {
    const prev = points[i-1];
    const curr = points[i];
    commands.push(['C', prev.outX, prev.outY, curr.inX, curr.inY, curr.x, curr.y]);
  }
  if (closed &amp;&amp; points.length &gt; 2) {
    const last = points[points.length-1];
    const first = points[0];
    commands.push(['C', last.outX, last.outY, first.inX, first.inY, first.x, first.y]);
    commands.push(['Z']);
  }
  return commands;
}

const bezierCreateViz = { nodes: [], guides: [], cursor: null };

function ensureBezierPreview(){
  if (vectorToolState.previewPath) return vectorToolState.previewPath;
  const p = new fabric.Path('M 0 0', {
    fill:'',
    stroke:'rgba(127,90,240,1)',
    strokeWidth:2.5,
    strokeLineCap:'round',
    strokeLineJoin:'round',
    objectCaching:false,
    selectable:false,
    evented:false,
    excludeFromExport:true
  });
  p.isBezierOverlay = true;
  vectorToolState.previewPath = p;
  canvas.add(p);
  return p;
}

function createCreationNode(x, y, kind='anchor'){
  const isAnchor = kind === 'anchor';
  const r = kind === 'cursor' ? getBezierHandleRadius('handle') : getBezierHandleRadius(isAnchor ? 'anchor' : 'handle');
  const sc = getHandleVisualScale();
  const node = new fabric.Circle({
    left:x, top:y, radius:r,
    originX:'center', originY:'center',
    fill: kind === 'cursor' ? '#fff' : (isAnchor ? '#ffffff' : '#111'),
    stroke:'#2f9bff', strokeWidth:2,
    selectable:false, evented:false, excludeFromExport:true
  });
  node.isBezierOverlay = true;
  node.set({ scaleX:sc, scaleY:sc });
  return node;
}

function createCreationGuide(x1,y1,x2,y2){
  const guide = new fabric.Line([x1,y1,x2,y2], {
    stroke:'rgba(47,155,255,.55)',
    strokeWidth:1.3,
    selectable:false,
    evented:false,
    excludeFromExport:true
  });
  guide.isBezierOverlay = true;
  return guide;
}

function clearBezierPreview(){
  const all = [vectorToolState.previewPath, ...bezierCreateViz.nodes, ...bezierCreateViz.guides, bezierCreateViz.cursor].filter(Boolean);
  all.forEach(o =&gt; { if (canvas.getObjects().includes(o)) canvas.remove(o); });
  vectorToolState.previewPath = null;
  bezierCreateViz.nodes = [];
  bezierCreateViz.guides = [];
  bezierCreateViz.cursor = null;
}

function updateBezierCreationPreview(pointer=null){
  if (vectorToolState.mode !== 'creating') return;
  const points = vectorToolState.points;

  const previewPoints = cloneBezierPoints(points);
  if (pointer) previewPoints.push(makeBezierPoint(pointer.x, pointer.y));
  if (previewPoints.length &gt;= 2) {
    const pre = ensureBezierPreview();
    const closePreview = !!vectorToolState.closed || !!vectorToolState.pendingClose;
    const commands = bezierPointsToPathCommands(previewPoints, closePreview);
    try {
      pre.set({ path: commands, dirty: true });
    } catch (err) {
      const lastPoint = previewPoints[previewPoints.length - 1] || null;
      console.warn('Bezier preview update failed; keeping last valid preview path.', {
        pointsLength: previewPoints.length,
        lastPoint,
        error: err
      });
    }
    pre.setCoords();
    canvas.requestRenderAll();
  }

  const shouldRemovePreview = points.length &lt; 2 &amp;&amp; !pointer;
  if (shouldRemovePreview &amp;&amp; vectorToolState.previewPath &amp;&amp; canvas.getObjects().includes(vectorToolState.previewPath)) {
    canvas.remove(vectorToolState.previewPath);
    vectorToolState.previewPath = null;
  }

  // rebuild construction overlays (nodes + structural lines)
  [...bezierCreateViz.nodes, ...bezierCreateViz.guides, bezierCreateViz.cursor].filter(Boolean).forEach(o =&gt; {
    if (canvas.getObjects().includes(o)) canvas.remove(o);
  });
  bezierCreateViz.nodes = [];
  bezierCreateViz.guides = [];

  points.forEach((pt) =&gt; {
    bezierCreateViz.nodes.push(createCreationNode(pt.x, pt.y));
    if (Math.hypot(pt.outX - pt.x, pt.outY - pt.y) &gt; 0.5) {
      bezierCreateViz.guides.push(createCreationGuide(pt.x, pt.y, pt.outX, pt.outY));
      bezierCreateViz.nodes.push(createCreationNode(pt.outX, pt.outY, 'handle'));
    }
    if (Math.hypot(pt.inX - pt.x, pt.inY - pt.y) &gt; 0.5) {
      bezierCreateViz.guides.push(createCreationGuide(pt.x, pt.y, pt.inX, pt.inY));
      bezierCreateViz.nodes.push(createCreationNode(pt.inX, pt.inY, 'handle'));
    }
  });

  if (pointer) {
    bezierCreateViz.cursor = createCreationNode(pointer.x, pointer.y, 'cursor');
  } else {
    bezierCreateViz.cursor = null;
  }

  [...bezierCreateViz.guides, ...bezierCreateViz.nodes].forEach(o =&gt; canvas.add(o));
  if (bezierCreateViz.cursor) canvas.add(bezierCreateViz.cursor);
  if (vectorToolState.previewPath &amp;&amp; canvas.getObjects().includes(vectorToolState.previewPath)) canvas.bringToFront(vectorToolState.previewPath);
  [...bezierCreateViz.guides, ...bezierCreateViz.nodes, bezierCreateViz.cursor].filter(Boolean).forEach(o =&gt; canvas.bringToFront(o));

  canvas.requestRenderAll();
}

function pathIsBezierEditable(pathObj){
  return !!pathObj &amp;&amp; (pathObj.type === 'path' || Array.isArray(pathObj.vectorModel?.points) || Array.isArray(pathObj.vectorModelV2?.points)) &amp;&amp; (Array.isArray(pathObj.vectorModel?.points) || Array.isArray(pathObj.vectorModelV2?.points) || Array.isArray(pathObj.path));
}

function convertVectorShapeToBezierPath(obj, modelKey='vectorModel'){
  if (!obj || obj.type === 'path') return obj;
  const m = obj[modelKey] || obj.vectorModel || obj.vectorModelV2;
  if (!m?.points?.length || m.points.length &lt; 2) return obj;
  const d = bezierPointsToPathData(m.points, !!m.closed);
  const path = new fabric.Path(d, {
    left: obj.left,
    top: obj.top,
    angle: obj.angle || 0,
    opacity: obj.opacity ?? 1,
    fill: obj.fill,
    stroke: obj.stroke,
    strokeWidth: obj.strokeWidth || 0,
    strokeLineCap: obj.strokeLineCap || 'round',
    strokeLineJoin: obj.strokeLineJoin || 'round',
    selectable: true,
    evented: true,
    hasControls: true,
    hasBorders: true
  });
  path.dataName = obj.dataName || obj.type;
  path[modelKey] = { points: cloneBezierPoints(m.points), closed: !!m.closed };
  if (obj.appearance) path.appearance = JSON.parse(JSON.stringify(obj.appearance));
  canvas.remove(obj);
  canvas.add(path);
  trackPathPosition(path);
  canvas.setActiveObject(path);
  canvas.requestRenderAll();
  return path;
}

function parseSimpleBezierModel(pathObj){
  const cmds = pathObj?.path || [];
  const m = cmds.find(c =&gt; c[0] === 'M');
  const c = cmds.find(c =&gt; c[0] === 'C');
  if (!m || !c) return null;
  return {
    closed: false,
    points: [
      { x:+m[1], y:+m[2], inX:+m[1], inY:+m[2], outX:+c[1], outY:+c[2], kind:'smooth' },
      { x:+c[5], y:+c[6], inX:+c[3], inY:+c[4], outX:+c[5], outY:+c[6], kind:'smooth' }
    ]
  };
}

function ensurePathVectorModel(pathObj, modelKey='vectorModel'){
  if (pathObj?.[modelKey]?.points?.length) {
    pathObj[modelKey].points.forEach(normalizeBezierPointKind);
    return pathObj[modelKey];
  }
  const parsed = parseSimpleBezierModel(pathObj);
  if (parsed) {
    parsed.points.forEach(normalizeBezierPointKind);
    pathObj[modelKey] = parsed;
    return parsed;
  }
  return null;
}

function applyVectorModelToPath(pathObj, modelKey='vectorModel'){
  const model = ensurePathVectorModel(pathObj, modelKey);
  if (!model || model.points.length &lt; 2) return;
  const d = bezierPointsToPathData(model.points, !!model.closed);
  pathObj.set({ path: parsePathDataSafe(d), dirty:true });
  pathObj.setCoords();
}

function startBezierCreation({ modelKey=getActiveBezierModelKey() }={}){
  if (bezierEditor.enabled) finalizeBezierEditor();
  vectorToolState.mode = 'creating';
  vectorToolState.modelKey = modelKey;
  vectorToolState.points = [];
  vectorToolState.closed = false;
  vectorToolState.dragPointIndex = -1;
  vectorToolState.segmentDrag = null;
  vectorToolState.dragStart = null;
  vectorToolState.dragStarted = false;
  vectorToolState.pendingClose = false;
  vectorToolState.lastPointAddedAt = 0;
  vectorToolState.lastPointAddedPos = null;
  clearBezierPreview();
  setInteractionState('creating');
}

function finishBezierCreation({toEditing=true}={}){
  const pts = vectorToolState.points;
  if (pts.length &lt; 2) {
    vectorToolState.mode = 'idle';
    setInteractionState('idle');
    clearBezierPreview();
    return null;
  }
  const d = bezierPointsToPathData(pts, vectorToolState.closed);
  const path = new fabric.Path(d, {
    fill:'',
    stroke:'rgba(127,90,240,.95)',
    strokeWidth:3,
    strokeLineCap:'round',
    strokeLineJoin:'round',
    selectable:true,
    evented:true,
    hasControls:true,
    hasBorders:true
  });
  path.dataName = 'Bezier';
  path[vectorToolState.modelKey || 'vectorModel'] = { points: cloneBezierPoints(pts), closed: !!vectorToolState.closed };
  trackPathPosition(path);
  canvas.add(path);
  canvas.setActiveObject(path);
  clearBezierPreview();
  vectorToolState.points = [];
  vectorToolState.closed = false;
  vectorToolState.dragStart = null;
  vectorToolState.dragStarted = false;
  vectorToolState.pendingClose = false;
  vectorToolState.lastPointAddedAt = 0;
  vectorToolState.lastPointAddedPos = null;
  vectorToolState.mode = toEditing ? 'editing' : 'idle';
  if (toEditing) attachBezierEditor(path, { handlesActive:false, modelKey: vectorToolState.modelKey || resolveBezierModelKey(path) });
  else { vectorToolState.pendingEditTarget = path; vectorToolState.pendingEditAt = performance.now(); setInteractionState('selection'); }
  canvas.requestRenderAll();
  snapshot();
  return path;
}

function undoBezierCreationAndFinalize(){
  if (vectorToolState.mode !== 'creating') return false;
  if (vectorToolState.points.length) vectorToolState.points.pop();
  if (vectorToolState.points.length &gt;= 2) {
    const path = finishBezierCreation({toEditing:false});
    if (path) {
      canvas.setActiveObject(path);
      setActiveTool('select');
      setStatus('Último ponto desfeito (Ctrl+Z) e forma finalizada.');
      return true;
    }
  }
  vectorToolState.points = [];
  vectorToolState.closed = false;
  vectorToolState.dragPointIndex = -1;
  vectorToolState.dragStart = null;
  vectorToolState.dragStarted = false;
  vectorToolState.pendingClose = false;
  vectorToolState.lastPointAddedAt = 0;
  vectorToolState.lastPointAddedPos = null;
  clearBezierPreview();
  vectorToolState.mode = 'idle';
  setInteractionState('idle');
  setActiveTool('select');
  return true;
}

function cancelBezierCreationStep(){
  if (vectorToolState.mode !== 'creating') return;
  if (vectorToolState.points.length &gt;= 2) {
    const path = finishBezierCreation({toEditing:false});
    if (path) {
      canvas.setActiveObject(path);
      setStatus('Desenho pausado no último ponto e convertido em objeto selecionado.');
      setActiveTool('select');
      return;
    }
  }
  vectorToolState.points = [];
  vectorToolState.closed = false;
  vectorToolState.dragPointIndex = -1;
  vectorToolState.dragStart = null;
  vectorToolState.dragStarted = false;
  vectorToolState.pendingClose = false;
  vectorToolState.lastPointAddedAt = 0;
  vectorToolState.lastPointAddedPos = null;
  clearBezierPreview();
  setStatus('Criação Bézier cancelada e pontos temporários limpos.');
  vectorToolState.mode = 'idle';
  setActiveTool('select');
}

function distance(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

function resetCreatePointToCorner(pt){
  if (!pt) return;
  pt.inX = pt.x; pt.inY = pt.y;
  pt.outX = pt.x; pt.outY = pt.y;
  pt.kind = 'corner';
}

function maybeCloseBezierPath(pointer){
  if (vectorToolState.points.length &lt; 3) return false;
  const first = vectorToolState.points[0];
  if (distance(pointer, first) &gt; BEZIER_CREATE_HIT / Math.max(zoom, .1)) return false;
  vectorToolState.closed = true;
  vectorToolState.pendingClose = true;
  vectorToolState.dragPointIndex = 0;
  vectorToolState.dragStart = { x:first.x, y:first.y };
  vectorToolState.dragStarted = false;
  return true;
}

function addBezierPoint(pointer, e){
  if (maybeCloseBezierPath(pointer)) return;
  const pts = vectorToolState.points;
  if (pts.length) {
    const last = pts[pts.length-1];
    const hit = distance(pointer, last) <= (BEZIER_CREATE_HIT / Math.max(zoom, .1));
    if (hit) {
      resetCreatePointToCorner(last);
      last.kind = 'corner';
      updateBezierCreationPreview();
      return;
    }
  }
  const now = performance.now();
  const lastPos = vectorToolState.lastPointAddedPos;
  const isV2 = (vectorToolState.modelKey === 'vectorModelV2' || activeTool === 'bezier-v2');
  const minInterval = isV2 ? 110 : 170;
  const minDistance = (isV2 ? 3.4 : 5) / Math.max(zoom, 0.1);
  const tooFast = now - Number(vectorToolState.lastPointAddedAt || 0) &lt; minInterval;
  const tooClose = !!lastPos &amp;&amp; distance(pointer, lastPos) &lt; minDistance;
  const repeatedClick = Number(e?.detail || 1) &gt; 1;
  if ((tooFast &amp;&amp; tooClose) || (isV2 &amp;&amp; repeatedClick)) return;

  const p = makeBezierPoint(pointer.x, pointer.y);
  pts.push(p);
  vectorToolState.lastPointAddedAt = now;
  vectorToolState.lastPointAddedPos = { x:pointer.x, y:pointer.y };
  vectorToolState.dragPointIndex = pts.length - 1;
  vectorToolState.dragStart = { x:pointer.x, y:pointer.y };
  vectorToolState.dragStarted = false;
  updateBezierCreationPreview();
}

function updateDraggedCreatePoint(pointer, e){
  const i = vectorToolState.dragPointIndex;
  if (i &lt; 0) return;

  if (vectorToolState.pendingClose) {
    const first = vectorToolState.points[0];
    if (!first) return;
    const start = vectorToolState.dragStart || { x:first.x, y:first.y };
    const moved = Math.hypot(pointer.x - start.x, pointer.y - start.y);
    if (!vectorToolState.dragStarted &amp;&amp; moved &lt; 4) return;
    vectorToolState.dragStarted = true;
    let dx = pointer.x - first.x;
    let dy = pointer.y - first.y;
    if (e.shiftKey) ({dx, dy} = normalizeVectorByShift(dx, dy));
    first.inX = first.x + dx;
    first.inY = first.y + dy;
    if (e.altKey) {
      first.outX = first.x;
      first.outY = first.y;
      first.kind = 'corner';
    } else {
      first.outX = first.x - dx;
      first.outY = first.y - dy;
      first.kind = 'smooth';
    }
    updateBezierCreationPreview();
    return;
  }

  const pt = vectorToolState.points[i];
  const start = vectorToolState.dragStart || { x: pt.x, y: pt.y };
  const moved = Math.hypot(pointer.x - start.x, pointer.y - start.y);
  if (!vectorToolState.dragStarted &amp;&amp; moved &lt; 4) return;
  vectorToolState.dragStarted = true;
  let dx = pointer.x - pt.x;
  let dy = pointer.y - pt.y;
  if (e.shiftKey) ({dx, dy} = normalizeVectorByShift(dx, dy));
  pt.outX = pt.x + dx;
  pt.outY = pt.y + dy;
  if (e.altKey) {
    pt.inX = pt.x; pt.inY = pt.y; pt.kind = 'corner';
  } else {
    pt.inX = pt.x - dx;
    pt.inY = pt.y - dy;
    pt.kind = 'smooth';
  }
  updateBezierCreationPreview();
}


function finalizeBezierPendingClose(){
  if (!vectorToolState.pendingClose) return;
  const path = finishBezierCreation({toEditing:false});
  if (path) {
    canvas.setActiveObject(path);
    setActiveTool('select');
  }
}

function getHandleVisualScale(){
  return 1 / Math.max(zoom, 0.05);
}

function getBezierHandleRadius(kind='handle'){
  return kind === 'anchor' ? 5.5 : 4.5;
}

function createBezierControl(x, y, role){
  const isAnchor = role.includes('anchor');
  const r = getBezierHandleRadius(isAnchor ? 'anchor' : 'handle');
  const c = new fabric.Circle({
    left:x, top:y, radius:r,
    originX:'center', originY:'center',
    fill:'#ffffff',
    stroke:'#2f9bff', strokeWidth:isAnchor ? 2 : 1.6,
    selectable:true, evented:true, hasControls:false, hasBorders:false,
    lockMovementX:false, lockMovementY:false,
    excludeFromExport:true, hoverCursor:'move',
    opacity:isAnchor ? 1 : .95
  });
  const sc = getHandleVisualScale();
  c.set({ scaleX:sc, scaleY:sc });
  c.bziRole = role;
  c.isBezierEditorControl = true;
  return c;
}

function removeBezierSelectionFrame(){
  const frame = bezierEditor.selectionFrame;
  if (frame && canvas.getObjects().includes(frame)) canvas.remove(frame);
  bezierEditor.selectionFrame = null;
}

function refreshBezierSelectionFrame(target = activeObj()){
  const canShow = activeTool === 'select' && !bezierEditor.enabled && !!target && pathIsBezierEditable(target);
  if (!canShow) {
    removeBezierSelectionFrame();
    return;
  }
  const model = ensurePathVectorModel(target, resolveBezierModelKey(target));
  if (!model?.closed || (model.points?.length || 0) < 3) {
    removeBezierSelectionFrame();
    return;
  }

  const bb = target.getBoundingRect(true, true);
  const side = Math.max(bb.width, bb.height);
  const left = bb.left + (bb.width - side) / 2;
  const top = bb.top + (bb.height - side) / 2;

  if (!bezierEditor.selectionFrame) {
    bezierEditor.selectionFrame = new fabric.Rect({
      left, top, width:Math.max(1, side), height:Math.max(1, side),
      fill:'',
      stroke:'rgba(47,155,255,.9)',
      strokeWidth:1,
      strokeDashArray:[5,4],
      selectable:false,
      evented:false,
      excludeFromExport:true
    });
    bezierEditor.selectionFrame.isBezierOverlay = true;
    canvas.add(bezierEditor.selectionFrame);
  } else {
    bezierEditor.selectionFrame.set({ left, top, width:Math.max(1, side), height:Math.max(1, side) });
  }
  bezierEditor.selectionFrame.setCoords();
  canvas.bringToFront(bezierEditor.selectionFrame);
}

function clearBezierEditor(){
  [...bezierEditor.links, ...bezierEditor.controls].forEach(o =&gt; {
    if (canvas.getObjects().includes(o)) canvas.remove(o);
  });
  bezierEditor.path = null;
  bezierEditor.controls = [];
  bezierEditor.links = [];
  bezierEditor.enabled = false;
  bezierEditor.handlesActive = false;
  bezierEditor.modelKey = 'vectorModel';
  setInteractionState('idle');
  bezierEditor.selectedAnchors = [];
  vectorToolState.segmentDrag = null;
  vectorToolState.pathDrag = null;
  vectorToolState.outsideClickPendingAt = 0;
  vectorToolState.outsideClickPendingCount = 0;
  vectorToolState.clickProbe = null;
  vectorToolState.clickPending = { target:null, at:0, count:0 };
  ensureBezierNodePanel();
  canvas.requestRenderAll();
}

function getPathModel(pathObj){
  return ensurePathVectorModel(pathObj, bezierEditor.modelKey || getActiveBezierModelKey());
}

function refreshBezierEditorControls(){
  const pathObj = bezierEditor.path;
  if (!pathObj) return;
  const model = getPathModel(pathObj);
  if (!model) return;
  const sc = getHandleVisualScale();

  // rebuild links fresh for simplicity
  bezierEditor.links.forEach(l =&gt; canvas.remove(l));
  bezierEditor.links = [];

  const byRole = Object.fromEntries(bezierEditor.controls.map(c =&gt; [c.bziRole, c]));
  const showHandles = !!bezierEditor.handlesActive;
  model.points.forEach((pt, i) =&gt; {
    const a = byRole[`anchor-${i}`];
    const hin = byRole[`in-${i}`];
    const hout = byRole[`out-${i}`];
    if (a) a.set({ left:pt.x, top:pt.y, scaleX:sc, scaleY:sc, visible:true, evented:true });
    if (hin) hin.set({ left:pt.inX, top:pt.inY, scaleX:sc, scaleY:sc, visible:showHandles, evented:showHandles });
    if (hout) hout.set({ left:pt.outX, top:pt.outY, scaleX:sc, scaleY:sc, visible:showHandles, evented:showHandles });

    if (showHandles) {
      const style = { stroke:'rgba(113,124,146,.55)', strokeWidth:1.15*sc, selectable:false, evented:false, excludeFromExport:true };
      if (distance({x:pt.x,y:pt.y},{x:pt.inX,y:pt.inY}) &gt; 0.5) bezierEditor.links.push(new fabric.Line([pt.x,pt.y,pt.inX,pt.inY], style));
      if (distance({x:pt.x,y:pt.y},{x:pt.outX,y:pt.outY}) &gt; 0.5) bezierEditor.links.push(new fabric.Line([pt.x,pt.y,pt.outX,pt.outY], style));
    }
  });

  bezierEditor.links.forEach(l =&gt; canvas.add(l));
  bezierEditor.controls.forEach(c =&gt; canvas.bringToFront(c));
  if (!bezierEditor.selectedAnchors.length &amp;&amp; model.points.length) selectBezierAnchorIndices([0]);
  else ensureBezierNodePanel();
  canvas.requestRenderAll();
}

function attachBezierEditor(pathObj, { handlesActive=false, modelKey=getActiveBezierModelKey() } = {}){
  if (!pathIsBezierEditable(pathObj)) return setStatus('Selecione uma curva vetorial para editar nós.');
  syncPathVectorModelByDelta(pathObj);
  const model = ensurePathVectorModel(pathObj, modelKey);
  if (!model || model.points.length &lt; 2) return setStatus('Curva incompatível para edição.');
  clearBezierEditor();
  removeBezierSelectionFrame();

  pathObj.set({ selectable:false, evented:true, hasControls:false, hasBorders:false, lockMovementX:true, lockMovementY:true });
  bezierEditor.path = pathObj;
  bezierEditor.enabled = true;
  bezierEditor.handlesActive = !!handlesActive;
  bezierEditor.modelKey = modelKey;
  vectorToolState.mode = 'editing';
  setInteractionState(bezierEditor.handlesActive ? 'edit-handles' : 'edit');

  const controls = [];
  model.points.forEach((pt, i) =&gt; {
    controls.push(createBezierControl(pt.x, pt.y, `anchor-${i}`));
    controls.push(createBezierControl(pt.inX, pt.inY, `in-${i}`));
    controls.push(createBezierControl(pt.outX, pt.outY, `out-${i}`));
  });

  controls.forEach(ctrl =&gt; {
    ctrl.__moved = false;
    ctrl.on('mousedown', (evt) =&gt; {
      ctrl.__moved = false;
      const [role, idxStr] = String(ctrl.bziRole).split('-');
      if (role === 'anchor') {
        const idx = Number(idxStr);
        if (evt?.e?.shiftKey) {
          const has = bezierEditor.selectedAnchors.includes(idx);
          const next = has ? bezierEditor.selectedAnchors.filter(n =&gt; n !== idx) : [...bezierEditor.selectedAnchors, idx];
          selectBezierAnchorIndices(next);
        } else {
          selectBezierAnchorIndices([idx]);
        }
      }
    });
    ctrl.on('moving', evt =&gt; {
      ctrl.__moved = true;
      const m = getPathModel(bezierEditor.path);
      if (!m) return;
      const [role, idxStr] = String(ctrl.bziRole).split('-');
      const i = Number(idxStr);
      const pt = m.points[i];
      if (!pt) return;
      normalizeBezierPointKind(pt);
      const cx = ctrl.left;
      const cy = ctrl.top;

      if ((role === 'in' || role === 'out') &amp;&amp; !bezierEditor.handlesActive) {
        ctrl.set({ left: role === 'in' ? pt.inX : pt.outX, top: role === 'in' ? pt.inY : pt.outY });
        canvas.requestRenderAll();
        return;
      }

      if (role === 'anchor') {
        setStatus(bezierEditor.handlesActive ? 'Modo edição com alças ativo.' : 'Modo edição de pontos ativo.');
        const dx = cx - pt.x;
        const dy = cy - pt.y;
        pt.x = cx; pt.y = cy;
        pt.inX += dx; pt.inY += dy;
        pt.outX += dx; pt.outY += dy;
      } else if (role === 'in') {
        setStatus('Modo edição com alças ativo.');
        let dx = cx - pt.x, dy = cy - pt.y;
        const e = evt?.e || {};
        if (e.shiftKey) ({dx,dy} = normalizeVectorByShift(dx,dy));
        pt.inX = pt.x + dx; pt.inY = pt.y + dy;
        if (!e.altKey) applyAnchorCoupling(pt, 'in', dx, dy);
      } else if (role === 'out') {
        setStatus('Modo edição com alças ativo.');
        let dx = cx - pt.x, dy = cy - pt.y;
        const e = evt?.e || {};
        if (e.shiftKey) ({dx,dy} = normalizeVectorByShift(dx,dy));
        pt.outX = pt.x + dx; pt.outY = pt.y + dy;
        if (!e.altKey) applyAnchorCoupling(pt, 'out', dx, dy);
      }

      applyVectorModelToPath(bezierEditor.path, bezierEditor.modelKey);
      refreshBezierEditorControls();
    });
    ctrl.on('mouseup', () =&gt; {
      if (ctrl.__moved) return;
      const m = getPathModel(bezierEditor.path);
      const [role, idxStr] = String(ctrl.bziRole).split('-');
      if (role !== 'anchor') return;
      const pt = m?.points?.[Number(idxStr)];
      if (!pt) return;
      normalizeBezierPointKind(pt);
      const isCorner = pt.kind === 'corner';
      pt.kind = isCorner ? 'smooth' : 'corner';
      pt.broken = !isCorner;
      if (isCorner) {
        pt.inX = pt.x - 36; pt.inY = pt.y;
        pt.outX = pt.x + 36; pt.outY = pt.y;
      } else {
        pt.inX = pt.x; pt.inY = pt.y;
        pt.outX = pt.x; pt.outY = pt.y;
      }
      applyVectorModelToPath(bezierEditor.path, bezierEditor.modelKey);
      refreshBezierEditorControls();
      snapshot();
    });
    ctrl.on('modified', () =&gt; snapshot());
  });

  bezierEditor.controls = controls;
  controls.forEach(c =&gt; canvas.add(c));
  selectBezierAnchorIndices([0]);
  refreshBezierEditorControls();
  setInteractionState(bezierEditor.handlesActive ? 'edit-handles' : 'edit');
}

function finalizeBezierEditor(){
  if (!bezierEditor.path) return clearBezierEditor();
  const p = bezierEditor.path;
  p.set({ selectable:true, evented:true, lockMovementX:false, lockMovementY:false, hasControls:true, hasBorders:true });
  clearBezierEditor();
  vectorToolState.mode = 'idle';
  canvas.setActiveObject(p);
  vectorToolState.pendingEditTarget = p;
  vectorToolState.pendingEditAt = performance.now();
  vectorToolState.pendingStateTarget = p;
  vectorToolState.pendingStateCount = 0;
  vectorToolState.pendingStateMode = 'to-edit';
  setInteractionState('selection');
  canvas.requestRenderAll();
}

function convertBezierToLine(){
  const p = bezierEditor.path || activeObj();
  if (!p) return setStatus('Selecione uma curva BZI primeiro.');
  const m = ensurePathVectorModel(p);
  if (!m) return setStatus('Curva incompatível para converter em linha.');
  m.points.forEach(pt =&gt; { pt.inX = pt.x; pt.inY = pt.y; pt.outX = pt.x; pt.outY = pt.y; pt.kind='corner'; });
  applyVectorModelToPath(p);
  refreshBezierEditorControls();
  snapshot();
  setStatus('BZI convertida para segmentos retos.');
}

function reverseBezierDirection(){
  const p = bezierEditor.path || activeObj();
  if (!p) return setStatus('Selecione uma curva BZI primeiro.');
  const m = ensurePathVectorModel(p);
  if (!m) return setStatus('Curva incompatível para inverter direção.');
  m.points.reverse();
  m.points = m.points.map(pt =&gt; ({ ...pt, inX:pt.outX, inY:pt.outY, outX:pt.inX, outY:pt.inY }));
  applyVectorModelToPath(p);
  refreshBezierEditorControls();
  snapshot();
  setStatus('Direção da BZI invertida.');
}

function getNearestBezierSegment(pathObj, pointer){
  const m = ensurePathVectorModel(pathObj);
  if (!m || m.points.length &lt; 2) return -1;
  let best = { i:-1, d:Infinity };
  const segCount = m.closed ? m.points.length : m.points.length - 1;
  const distToLine = (p,a,b) =&gt; {
    const A = p.x-a.x, B = p.y-a.y, C = b.x-a.x, D = b.y-a.y;
    const dot = A*C + B*D;
    const lenSq = C*C + D*D || 1;
    const t = Math.max(0, Math.min(1, dot/lenSq));
    const x = a.x + C*t, y = a.y + D*t;
    return Math.hypot(p.x-x,p.y-y);
  };
  for (let i=0;i&lt;segCount;i++) {
    const p0 = m.points[i], p1 = m.points[(i+1)%m.points.length];
    const d = distToLine(pointer, {x:p0.x,y:p0.y}, {x:p1.x,y:p1.y});
    if (d &lt; best.d) best = {i, d};
  }
  return best.i;
}

function insertPointOnSegment(pathObj, segIndex){
  const m = ensurePathVectorModel(pathObj);
  if (!m) return;
  const n = m.points.length;
  const i0 = segIndex;
  const i1 = (segIndex + 1) % n;
  const p0 = m.points[i0];
  const p1 = m.points[i1];
  const lerp = (a,b,t=.5) =&gt; ({x:a.x + (b.x-a.x)*t, y:a.y + (b.y-a.y)*t});
  const P0 = {x:p0.x,y:p0.y}, P1={x:p0.outX,y:p0.outY}, P2={x:p1.inX,y:p1.inY}, P3={x:p1.x,y:p1.y};
  const Q0 = lerp(P0,P1), Q1 = lerp(P1,P2), Q2 = lerp(P2,P3);
  const R0 = lerp(Q0,Q1), R1 = lerp(Q1,Q2);
  const S = lerp(R0,R1);

  p0.outX = Q0.x; p0.outY = Q0.y;
  p1.inX = Q2.x; p1.inY = Q2.y;
  const mid = { x:S.x, y:S.y, inX:R0.x, inY:R0.y, outX:R1.x, outY:R1.y, kind:'smooth' };
  m.points.splice(i1, 0, mid);
  applyVectorModelToPath(pathObj, bezierEditor.modelKey);
  attachBezierEditor(pathObj, { handlesActive: bezierEditor.handlesActive, modelKey: bezierEditor.modelKey });
  selectBezierAnchorIndices([i1]);
  snapshot();
}



function removePointAtIndex(pathObj, index){
  const m = ensurePathVectorModel(pathObj);
  if (!m || !Number.isFinite(index) || !m.points[index]) return;
  const minAllowed = m.closed ? 3 : 2;
  if (m.points.length &lt;= minAllowed) {
    setStatus('Não é possível remover mais nós desta curva.');
    return;
  }
  m.points.splice(index, 1);
  applyVectorModelToPath(pathObj, bezierEditor.modelKey);
  attachBezierEditor(pathObj, { handlesActive: bezierEditor.handlesActive, modelKey: bezierEditor.modelKey });
  const next = Math.max(0, Math.min(index - 1, m.points.length - 1));
  selectBezierAnchorIndices([next]);
  snapshot();
}

function addLayer() {
  ensureArtboard();
  const idx = canvas.getObjects().filter(o=&gt;!isGuide(o)).length + 1;
  const l = new fabric.Rect({
    left: artboard.left + 100, top: artboard.top + 100,
    width: 260, height: 160, rx: 12, ry: 12,
    fill:'rgba(255,255,255,.08)', stroke:'rgba(255,255,255,.22)', strokeWidth:1,
    opacity:1, globalCompositeOperation:'source-over'
  });
  l.dataName = `Layer ${idx}`;
  canvas.add(l); canvas.setActiveObject(l); canvas.requestRenderAll();
  refreshLayers(); refreshProps();
  setStatus('Nova layer criada');
}

function bringForwardSelection(){
  const obj = activeObj(); if(!obj) return;
  canvas.bringForward(obj); canvas.requestRenderAll(); refreshLayers();
}
function sendBackwardSelection(){
  const obj = activeObj(); if(!obj) return;
  canvas.sendBackwards(obj); canvas.requestRenderAll(); refreshLayers();
}

function importExternalFile(file){
  if(!file) return;
  const name = String(file.name||'').toLowerCase();
  const isSvg = file.type==='image/svg+xml' || name.endsWith('.svg');
  const isRaster = file.type.startsWith('image/') || ['.png','.jpg','.jpeg','.webp','.gif'].some(ext=&gt;name.endsWith(ext));
  const isVectorUnsupported = ['.ai','.eps'].some(ext=&gt;name.endsWith(ext));

  if (isSvg) {
    const fr = new FileReader();
    fr.onload = ev =&gt; loadSVGFromParent(String(ev.target?.result||''));
    fr.readAsText(file);
    return;
  }
  if (isRaster) {
    const fr = new FileReader();
    fr.onload = ev =&gt; {
      fabric.Image.fromURL(ev.target.result, img =&gt; {
        ensureArtboard();
        const maxW = Math.min(docW * 0.8, 600);
        if (img.width &gt; maxW) img.scaleToWidth(maxW);
        img.set({ left: artboard.left + 40, top: artboard.top + 40, dataName:file.name || 'Imagem colada' });
        canvas.add(img); canvas.setActiveObject(img); canvas.requestRenderAll();
        refreshLayers();
      });
    };
    fr.readAsDataURL(file);
    return;
  }
  if (isVectorUnsupported) {
    ensureArtboard();
    const ph = new fabric.Rect({ left:artboard.left+80, top:artboard.top+80, width:260, height:120, fill:'rgba(127,90,240,.12)', stroke:'rgba(127,90,240,.6)', strokeDashArray:[6,4] });
    const label = new fabric.Text(file.name + ' (importado)', { left:artboard.left+94, top:artboard.top+128, fontSize:14, fill:'#fff', fontFamily:'Outfit' });
    const g = new fabric.Group([ph,label], { dataName:file.name || 'Arquivo vetorial' });
    canvas.add(g); canvas.setActiveObject(g); canvas.requestRenderAll(); refreshLayers();
    setStatus('Arquivo importado como referência visual.');
    return;
  }
  setStatus('Formato não suportado para importação.');
}


// ─── Serialization helpers ───────────────────────────────
const SERIALIZE_PROPS = ['excludeFromExport','dataName','vectorModel','vectorModelV2'];

function refreshObjectCoords(){
  canvas.getObjects().forEach(o =&gt; o.setCoords());
}

function trackPathPosition(pathObj){
  if (!pathObj) return;
  const matrix = pathObj.calcTransformMatrix();
  pathObj.__bziLastMatrix = Array.isArray(matrix) ? matrix.slice() : fabric.iMatrix.concat();
}

function syncPathVectorModelByDelta(pathObj){
  const models = ['vectorModel','vectorModelV2'].map(k =&gt; pathObj?.[k]).filter(m =&gt; m?.points?.length);
  if (!models.length) return;
  const prevMatrix = Array.isArray(pathObj.__bziLastMatrix) ? pathObj.__bziLastMatrix : pathObj.calcTransformMatrix();
  const nextMatrix = pathObj.calcTransformMatrix();
  const invPrev = fabric.util.invertTransform(prevMatrix);
  if (!invPrev) {
    trackPathPosition(pathObj);
    return;
  }
  const delta = fabric.util.multiplyTransformMatrices(nextMatrix, invPrev);
  const isAlmostIdentity =
    Math.abs(delta[0] - 1) &lt; 0.0001 &amp;&amp;
    Math.abs(delta[1]) &lt; 0.0001 &amp;&amp;
    Math.abs(delta[2]) &lt; 0.0001 &amp;&amp;
    Math.abs(delta[3] - 1) &lt; 0.0001 &amp;&amp;
    Math.abs(delta[4]) &lt; 0.0001 &amp;&amp;
    Math.abs(delta[5]) &lt; 0.0001;
  if (isAlmostIdentity) return;
  models.forEach(model =&gt; model.points.forEach(pt =&gt; {
    const a = fabric.util.transformPoint(new fabric.Point(pt.x, pt.y), delta);
    const i = fabric.util.transformPoint(new fabric.Point(pt.inX, pt.inY), delta);
    const o = fabric.util.transformPoint(new fabric.Point(pt.outX, pt.outY), delta);
    pt.x = a.x; pt.y = a.y;
    pt.inX = i.x; pt.inY = i.y;
    pt.outX = o.x; pt.outY = o.y;
  }));
  trackPathPosition(pathObj);
}

// ─── History ─────────────────────────────────────────────
const history = { stack:[], idx:-1, lock:false };
function snapshot() {
  if (history.lock) return;
  try {
    const json = canvas.toJSON(SERIALIZE_PROPS);
    history.stack = history.stack.slice(0, history.idx+1);
    history.stack.push(json);
    if (history.stack.length &gt; 60) history.stack.shift();
    history.idx = history.stack.length - 1;
  } catch(e) {}
}
function restore(idx) {
  if (idx &lt; 0 || idx &gt;= history.stack.length) return;
  clearBezierPreview();
  clearBezierEditor();
  history.lock = true;
  canvas.loadFromJSON(history.stack[idx], () =&gt; {
    refreshObjectCoords();
    canvas.getObjects().forEach(o =&gt; { if (pathIsBezierEditable(o)) trackPathPosition(o); });
    canvas.requestRenderAll();
    history.idx = idx;
    history.lock = false;
    refreshLayers(); refreshProps();
  });
}
function undo() {
  if (history.idx &lt;= 0) return;
  if (artboardCreateState.ghost &amp;&amp; canvas.getObjects().includes(artboardCreateState.ghost)) {
    canvas.remove(artboardCreateState.ghost);
  }
  artboardCreateState.active = false;
  artboardCreateState.start = null;
  artboardCreateState.ghost = null;
  restore(history.idx-1);
}
function redo() { if (history.idx &lt; history.stack.length-1) restore(history.idx+1); }

canvas.on('object:added', e =&gt; {
  if (history.lock || !e.target || e.target === artboardCreateState.ghost || isEditorAuxObject(e.target)) return;
  snapshot();
});
canvas.on('object:modified', e =&gt; {
  if (history.lock || !e.target || isEditorAuxObject(e.target)) return;
  snapshot();
});
canvas.on('object:removed', e =&gt; {
  if (!history.lock &amp;&amp; e.target &amp;&amp; !isEditorAuxObject(e.target)) snapshot();
  removeObjectFromArtboard(e.target || null);
});
canvas.on('object:added', e =&gt; {
  const obj = e.target;
  if (!obj || isGuide(obj) || obj.isBezierEditorControl || obj.isBezierOverlay || obj.isArtboardBoard) return;
  if (!obj.id) obj.id = 'o_' + Math.random().toString(36).slice(2,10);
  syncObjectArtboardMembership(obj);
  orderArtboard();
});
canvas.on('object:modified', e =&gt; {
  const obj = e.target;
  if (!obj || !pathIsBezierEditable(obj)) return;
  syncPathVectorModelByDelta(obj);
  trackPathPosition(obj);
});

canvas.on('object:moving', e =&gt; {
  smartOverlayState.liveMeasure = true;
  applySmartSnap(e.target);
  refreshAlignmentAssist();
});
canvas.on('object:scaling', () =&gt; refreshAlignmentAssist());
canvas.on('object:rotating', () =&gt; refreshAlignmentAssist());
canvas.on('mouse:up', () =&gt; {
  clearSmartOverlayState({ keepMeasurements:isAltMeasureDown });
  refreshAlignmentAssist();
});
canvas.on('after:render', () =&gt; {
  renderSmartOverlays();
  updateTwoItemOverlay();
});


// ─── Delete / Duplicate ──────────────────────────────────
function del() {
  if (vectorToolState.mode === 'creating') {
    vectorToolState.points = [];
    vectorToolState.closed = false;
    vectorToolState.dragPointIndex = -1;
    vectorToolState.dragStart = null;
    vectorToolState.dragStarted = false;
    vectorToolState.pendingClose = false;
    clearBezierPreview();
  }

  const objs = selectedObjects();
  if(!objs.length) return;

  if (bezierEditor.enabled &amp;&amp; objs.includes(bezierEditor.path)) {
    clearBezierEditor();
  }

  objs.forEach(o =&gt; canvas.remove(o));
  canvas.discardActiveObject();
  canvas.requestRenderAll();
  refreshProps();
  refreshLayers();
}
function duplicate() {
  const o = activeObj(); if(!o) return;
  clearSmartOverlayState({ keepMeasurements:isAltMeasureDown });
  o.clone(cl =&gt; {
    cl.set({ left:(o.left||0)+18, top:(o.top||0)+18 });
    canvas.add(cl); canvas.setActiveObject(cl);
    canvas.requestRenderAll(); refreshProps(); refreshLayers();
  });
}


function selectedObjects() {
  const active = canvas.getActiveObject();
  if(!active || isGuide(active)) return [];
  if(active.type === 'activeSelection') {
    return active.getObjects().filter(o =&gt; !isGuide(o));
  }
  return [active];
}

function nudgeBy(obj, dx=0, dy=0) {
  obj.set({ left: (obj.left||0) + dx, top: (obj.top||0) + dy });
  obj.setCoords();
}

function getAlignReferenceRect(objs) {
  ensureArtboard();
  if(!artboard) return null;

  const target = $('alignTarget')?.value || 'layout';
  if(target !== 'object') {
    return { left: artboard.left, top: artboard.top, width: docW, height: docH };
  }

  const active = canvas.getActiveObject();
  if(!active || active.type !== 'activeSelection') {
    setStatus('No modo objeto, selecione 2+ elementos');
    return null;
  }
  const list = active.getObjects().filter(o =&gt; !isGuide(o));
  if(list.length &lt; 2) {
    setStatus('Selecione ao menos 2 elementos para alinhar por objeto');
    return null;
  }

  const anchor = list[list.length - 1];
  const b = anchor.getBoundingRect(true, true);
  return { left: b.left, top: b.top, width: b.width, height: b.height, anchor };
}

function alignSelection(mode) {
  ensureArtboard();
  const objs = selectedObjects();
  const ref = getAlignReferenceRect(objs);
  if(!objs.length || !ref) return;
  const L = ref.left, T = ref.top;
  const R = L + ref.width, B = T + ref.height;

  objs.forEach(obj =&gt; {
    if(ref.anchor &amp;&amp; obj === ref.anchor) return;
    const b = obj.getBoundingRect(true, true);
    let dx = 0, dy = 0;
    if(mode === 'left') dx = L - b.left;
    if(mode === 'center') dx = (L + ref.width / 2) - (b.left + b.width / 2);
    if(mode === 'right') dx = R - (b.left + b.width);
    if(mode === 'top') dy = T - b.top;
    if(mode === 'middle') dy = (T + ref.height / 2) - (b.top + b.height / 2);
    if(mode === 'bottom') dy = B - (b.top + b.height);
    if(dx || dy) nudgeBy(obj, dx, dy);
  });

  canvas.requestRenderAll();
  refreshAlignmentAssist();
  refreshProps();
  refreshLayers();
  snapshot();
  setStatus('Alinhamento aplicado');
}

async function syncTextStyleRender(obj) {
  if(!obj || !(obj.type==='textbox'||obj.type==='text'||obj.type==='i-text')) return;
  try {
    if(document.fonts &amp;&amp; obj.fontFamily) {
      const size = obj.fontSize || 16;
      await document.fonts.load(`${size}px "${obj.fontFamily}"`);
    }
  } catch(_) {}
  canvas.requestRenderAll();
}

function ensureGoogleFont(fontName) {
  const font = (fontName || '').trim();
  if(!font) return false;
  const q = font.split(/\s+/).join('+');
  const id = `gf-${q.toLowerCase()}`;
  if(!document.getElementById(id)) {
    const link = document.createElement('link');
    link.id = id;
    link.rel = 'stylesheet';
    link.href = `https://fonts.googleapis.com/css2?family=${q}:wght@300;400;500;600;700;800;900&amp;display=swap`;
    document.head.appendChild(link);
  }
  return true;
}

async function loadGoogleFontForSelection() {
  const input = $('pGoogleFont');
  const font = (input?.value || '').trim();
  if(!font) { setStatus('Informe o nome da fonte Google'); return; }
  ensureGoogleFont(font);
  const obj = activeObj();
  if(obj &amp;&amp; (obj.type==='textbox'||obj.type==='text'||obj.type==='i-text')) {
    obj.set({ fontFamily: font });
    if(UI.font) {
      const hasOpt = [...UI.font.options].some(o =&gt; o.value === font);
      if(!hasOpt) {
        const opt = document.createElement('option');
        opt.value = font; opt.textContent = font;
        UI.font.appendChild(opt);
      }
      UI.font.value = font;
    }
    await syncTextStyleRender(obj);
    setStatus(`Fonte carregada: ${font}`);
    return;
  }
  setStatus(`Fonte carregada: ${font}. Selecione um texto para aplicar.`);
}

function distributeSelection(axis='x') {
  const objs = selectedObjects();
  if(objs.length &lt; 3) {
    setStatus('Selecione 3+ elementos para distribuir');
    return;
  }

  const sorted = objs.slice().sort((a,b) =&gt; {
    const ba = getBounds(a);
    const bb = getBounds(b);
    return axis === 'x' ? ba.left - bb.left : ba.top - bb.top;
  });

  const firstB = getBounds(sorted[0]);
  const lastB = getBounds(sorted[sorted.length - 1]);
  const occupied = sorted.reduce((sum,obj) =&gt; {
    const b = getBounds(obj);
    return sum + (axis === 'x' ? b.width : b.height);
  }, 0);

  const span = axis === 'x' ? (lastB.right - firstB.left) : (lastB.bottom - firstB.top);
  const gap = (span - occupied) / (sorted.length - 1);

  let cursor = axis === 'x' ? firstB.left : firstB.top;
  sorted.forEach(obj =&gt; {
    const b = getBounds(obj);
    if(axis === 'x') {
      nudgeBy(obj, cursor - b.left, 0);
      cursor += b.width + gap;
    } else {
      nudgeBy(obj, 0, cursor - b.top);
      cursor += b.height + gap;
    }
  });

  canvas.requestRenderAll();
  refreshAlignmentAssist();
  refreshProps();
  refreshLayers();
  snapshot();
  setStatus(axis === 'x' ? 'Distribuição horizontal aplicada' : 'Distribuição vertical aplicada');
}

function groupSelection() {
  const active = canvas.getActiveObject();
  if(active &amp;&amp; active.type === 'activeSelection') {
    active.toGroup();
    canvas.requestRenderAll();
    refreshLayers();
    setStatus('Grupo criado');
    return;
  }
  setStatus('Selecione 2+ elementos para agrupar');
}

function ungroupSelection() {
  const active = canvas.getActiveObject();
  if(active &amp;&amp; active.type === 'group') {
    active.toActiveSelection();
    canvas.requestRenderAll();
    refreshLayers();
    setStatus('Grupo desfeito');
  }
}

// ─── Properties panel ────────────────────────────────────
const UI = {
  x:$('pX'), y:$('pY'), w:$('pW'), h:$('pH'),
  r:$('pR'), o:$('pO'), blend:$('pBlend'),
  fill:$('pFill'), stroke:$('pStroke'), strokeW:$('pStrokeW'), rx:$('pRx'),
  fillPaint:$('pFillPaint'), strokePaint:$('pStrokePaint'),
  font:$('pFont'), fontSize:$('pFontSize'),
  textColor:$('pTextColor'), align:null
};

function ensureAppearanceData(obj){
  if (!obj) return null;
  if (!obj.appearance || typeof obj.appearance !== 'object') {
    obj.appearance = {
      fills: [{ type:'solid', color: normalizeHex(typeof obj.fill === 'string' ? obj.fill : '#111111') || '#111111' }],
      strokes: [{ type:'solid', color: normalizeHex(typeof obj.stroke === 'string' ? obj.stroke : '#000000') || '#000000', width: Number(obj.strokeWidth || 0) }]
    };
  }
  if (!Array.isArray(obj.appearance.fills) || !obj.appearance.fills.length) obj.appearance.fills = [{ type:'none', color:'#111111' }];
  if (!Array.isArray(obj.appearance.strokes) || !obj.appearance.strokes.length) obj.appearance.strokes = [{ type:'none', color:'#000000', width:0 }];
  return obj.appearance;
}

function makeHatchPattern(fg='#00000022'){
  const pc = document.createElement('canvas');
  pc.width = 12; pc.height = 12;
  const ctx = pc.getContext('2d');
  ctx.clearRect(0,0,12,12);
  ctx.strokeStyle = fg;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0,12); ctx.lineTo(12,0);
  ctx.stroke();
  return new fabric.Pattern({ source: pc, repeat:'repeat' });
}

function paintValueByType(kind, type, color, obj){
  const base = normalizeHex(color) || (kind === 'fill' ? '#111111' : '#000000');
  const b = obj?.getBoundingRect?.(true, true) || { width:200, height:120, left:0, top:0 };
  if (type === 'none') return kind === 'fill' ? '' : null;
  if (type === 'solid') return base;
  if (type === 'gradient') {
    return new fabric.Gradient({
      type: 'linear', gradientUnits: 'pixels',
      coords: { x1:b.left, y1:b.top, x2:b.left + Math.max(b.width, 32), y2:b.top + Math.max(b.height, 32) },
      colorStops: [{ offset:0, color:base }, { offset:1, color:'#ffffff' }]
    });
  }
  if (type === 'pattern') return makeHatchPattern(base + '99');
  if (type === 'filter') return base + 'cc';
  return base;
}

function applyAppearanceStack(obj){
  if (!obj) return;
  const ap = ensureAppearanceData(obj);
  const fillLayer = ap.fills[ap.fills.length - 1] || { type:'none', color:'#111111' };
  const strokeLayer = ap.strokes[ap.strokes.length - 1] || { type:'none', color:'#000000', width:0 };
  const fillValue = paintValueByType('fill', fillLayer.type, fillLayer.color, obj);
  const strokeValue = paintValueByType('stroke', strokeLayer.type, strokeLayer.color, obj);
  obj.set({
    fill: fillValue,
    stroke: strokeValue,
    strokeWidth: Number.isFinite(Number(strokeLayer.width)) ? Number(strokeLayer.width) : Number(obj.strokeWidth || 0),
    shadow: (fillLayer.type === 'filter' || strokeLayer.type === 'filter')
      ? new fabric.Shadow({ color:'rgba(0,0,0,.35)', blur:14, offsetX:2, offsetY:3 })
      : null
  });
}

function activeObj() {
  const o = canvas.getActiveObject();
  return (o &amp;&amp; !isGuide(o)) ? o : null;
}
function num(v, fb=0) { const n=Number(v); return Number.isFinite(n)?n:fb; }
function normalizeHex(c) {
  if(!c) return null;
  const s = String(c).trim();
  if(/^#[0-9a-f]{3}$/i.test(s)) return '#'+s.slice(1).split('').map(x=&gt;x+x).join('');
  if(/^#[0-9a-f]{6}$/i.test(s)) return s;
  return null;
}

function isTextObject(obj){
  return !!obj &amp;&amp; (obj.type==='textbox' || obj.type==='text' || obj.type==='i-text');
}

function focusTextPanel(show){
  const tabsRoot = $('propTabs');
  if (show &amp;&amp; tabsRoot) {
    const corTab = tabsRoot.querySelector('[data-tab="cor"]');
    corTab?.click();
    $('propText')?.scrollIntoView({behavior:'smooth', block:'nearest'});
  }
}

function syncFloatingTextPanel(){
  const obj = activeObj();
  const panel = $('textFloatPanel');
  if(!panel) return;
  const disabled = !isTextObject(obj);
  ['tfFontSize','tfColor','tfLineHeight','tfLetterSpacing','tfWeight','tfStyle'].forEach(id=&gt;{ const el=$(id); if(el) el.disabled = disabled; });
  if(disabled) return;
  if($('tfFontSize')) $('tfFontSize').value = Math.round(obj.fontSize||16);
  if($('tfColor')) $('tfColor').value = normalizeHex(obj.fill)||'#111111';
  if($('tfLineHeight')) $('tfLineHeight').value = Number(obj.lineHeight||1.2).toFixed(1);
  if($('tfLetterSpacing')) $('tfLetterSpacing').value = Math.round((obj.charSpacing||0)/50);
  if($('tfWeight')) $('tfWeight').value = String(obj.fontWeight||400);
  if($('tfStyle')) $('tfStyle').value = obj.fontStyle||'normal';
  const align = obj.textAlign||'left';
  document.querySelectorAll('#tfAlignSeg .seg-opt').forEach(btn=&gt;btn.classList.toggle('on', btn.dataset.val===align));
}


function renderAppearancePanel(){
  const obj = activeObj();
  const fillList = $('appearanceFillList');
  const strokeList = $('appearanceStrokeList');
  if (!fillList || !strokeList) return;
  if (!obj) { fillList.innerHTML = ''; strokeList.innerHTML = ''; return; }
  const ap = ensureAppearanceData(obj);
  fillList.innerHTML = ap.fills.map((f, i) => `&lt;div class="rp-row" style="margin:4px 0"&gt;&lt;span class="rp-chip"&gt;#${i+1} ${f.type}&lt;/span&gt;&lt;input class="field-input appearance-fill-color" data-idx="${i}" type="color" value="${normalizeHex(f.color)||'#111111'}" style="height:26px"&gt;&lt;button class="rp-icon-btn appearance-fill-del" data-idx="${i}" title="Remover"&gt;🗑&lt;/button&gt;&lt;/div&gt;`).join('');
  strokeList.innerHTML = ap.strokes.map((st, i) => `&lt;div class="rp-row" style="margin:4px 0"&gt;&lt;span class="rp-chip"&gt;#${i+1} ${st.type}&lt;/span&gt;&lt;input class="field-input appearance-stroke-color" data-idx="${i}" type="color" value="${normalizeHex(st.color)||'#000000'}" style="height:26px"&gt;&lt;input class="field-input appearance-stroke-width" data-idx="${i}" type="number" min="0" step="1" value="${Number(st.width||0)}" style="width:64px;height:26px"&gt;&lt;button class="rp-icon-btn appearance-stroke-del" data-idx="${i}" title="Remover"&gt;🗑&lt;/button&gt;&lt;/div&gt;`).join('');
}

function refreshProps() {
  const obj = activeObj();
  const info = $('selInfo');

  // alignment seg
  const segs = document.querySelectorAll('#alignSeg .seg-opt');

  if (!obj) {
    if (info) info.textContent = 'Nada selecionado';
    const c1=$('ctxSelectionState'); if(c1) c1.innerHTML='&lt;strong&gt;Nenhuma seleção&lt;/strong&gt;';
    const c2=$('canvasSelectionState'); if(c2) c2.innerHTML='&lt;strong&gt;Nenhuma seleção&lt;/strong&gt;';
    syncFloatingTextPanel();
    return;
  }

  if (info) {
    const typeNames = {textbox:'Texto',text:'Texto','i-text':'Texto',rect:'Retângulo',circle:'Círculo',ellipse:'Elipse',line:'Linha',image:'Imagem',group:'Grupo'};
    const selType = typeNames[obj.type] || obj.type;
    info.textContent = selType;
    const c1=$('ctxSelectionState'); if(c1) c1.innerHTML='&lt;strong&gt;'+selType+'&lt;/strong&gt;';
    const c2=$('canvasSelectionState'); if(c2) c2.innerHTML='&lt;strong&gt;'+selType+'&lt;/strong&gt;';
  }

  const sw = obj.getScaledWidth ? obj.getScaledWidth() : (obj.width||0);
  const sh = obj.getScaledHeight ? obj.getScaledHeight() : (obj.height||0);
  if(UI.x) UI.x.value = Math.round(obj.left??0);
  if(UI.y) UI.y.value = Math.round(obj.top??0);
  if(UI.w) UI.w.value = Math.round(sw);
  if(UI.h) UI.h.value = Math.round(sh);
  if(UI.r) UI.r.value = Math.round(obj.angle??0);
  if(UI.o) UI.o.value = obj.opacity??1;
  if(UI.blend) UI.blend.value = obj.globalCompositeOperation || 'source-over';

  const f = (typeof obj.fill==='string') ? obj.fill : '#111111';
  if(UI.fill) UI.fill.value = normalizeHex(f) || '#111111';
  if(UI.textColor) UI.textColor.value = normalizeHex(f) || '#111111';
  const s = (typeof obj.stroke==='string') ? obj.stroke : '#000000';
  if(UI.stroke) UI.stroke.value = normalizeHex(s) || '#000000';
  if(UI.strokeW) UI.strokeW.value = obj.strokeWidth??0;
  if(UI.rx) UI.rx.value = Math.round(obj.rx??obj.ry??0);

  const ap = ensureAppearanceData(obj);
  if (UI.fillPaint) UI.fillPaint.value = ap?.fills?.[ap.fills.length-1]?.type || 'solid';
  if (UI.strokePaint) UI.strokePaint.value = ap?.strokes?.[ap.strokes.length-1]?.type || 'solid';
  renderAppearancePanel();

  if (obj.type==='textbox'||obj.type==='text'||obj.type==='i-text') {
    focusTextPanel(true);
    if(UI.font &amp;&amp; obj.fontFamily) UI.font.value = obj.fontFamily;
    if(UI.fontSize) UI.fontSize.value = obj.fontSize??'';
    const align = obj.textAlign || 'left';
    segs.forEach(s =&gt; {
      s.classList.toggle('on', s.dataset.val === align);
    });
  }
  syncFloatingTextPanel();
}

function applyProps(key) {
  const obj = activeObj(); if(!obj) return;
  obj.set({
    left: num(UI.x?.value, obj.left||0),
    top:  num(UI.y?.value, obj.top||0),
    angle: num(UI.r?.value, obj.angle||0),
    opacity: num(UI.o?.value, obj.opacity??1),
    globalCompositeOperation: UI.blend?.value || obj.globalCompositeOperation || 'source-over'
  });

  const tw = num(UI.w?.value, obj.getScaledWidth());
  const th = num(UI.h?.value, obj.getScaledHeight());
  if (tw&gt;1 &amp;&amp; th&gt;1) {
    if (obj.type==='line') {
      obj.set({ x2:(obj.x1??0)+tw, y2:(obj.y1??0)+th });
    } else {
      obj.set({ scaleX: tw/(obj.width||1), scaleY: th/(obj.height||1) });
    }
  }

  const ap = ensureAppearanceData(obj);
  if(key==='fill'||!key){
    if (ap?.fills?.length) ap.fills[ap.fills.length-1].color = UI.fill?.value || ap.fills[ap.fills.length-1].color;
  }
  if(key==='stroke'||!key){
    if (ap?.strokes?.length) ap.strokes[ap.strokes.length-1].color = UI.stroke?.value || ap.strokes[ap.strokes.length-1].color;
  }
  if(key==='strokeW'||!key){
    const w = num(UI.strokeW?.value, obj.strokeWidth||0);
    if (ap?.strokes?.length) ap.strokes[ap.strokes.length-1].width = w;
    obj.set({ strokeWidth: w });
  }
  if(key==='fillPaint' && UI.fillPaint && ap?.fills?.length) ap.fills[ap.fills.length-1].type = UI.fillPaint.value;
  if(key==='strokePaint' && UI.strokePaint && ap?.strokes?.length) ap.strokes[ap.strokes.length-1].type = UI.strokePaint.value;
  applyAppearanceStack(obj);
  if(UI.rx &amp;&amp; (obj.type==='rect'||obj.rx!=null)) {
    const rv = clamp(num(UI.rx.value, obj.rx||0), 0, 2000);
    obj.set({ rx:rv, ry:rv });
  }

  if (obj.type==='textbox'||obj.type==='text'||obj.type==='i-text') {
    if(UI.font?.value) obj.set({ fontFamily: UI.font.value });
    if(UI.fontSize?.value) obj.set({ fontSize: clamp(num(UI.fontSize.value, obj.fontSize||16), 6, 512) });
    if(key==='textColor'||key==='fill') obj.set({ fill: UI.textColor?.value || obj.fill });
    syncTextStyleRender(obj);
  }

  obj.setCoords(); canvas.requestRenderAll();
}

function bindInput(el, k) {
  if(!el) return;
  el.addEventListener('input', () =&gt; applyProps(k));
  el.addEventListener('change', () =&gt; applyProps(k));
}
bindInput(UI.x,'pos'); bindInput(UI.y,'pos'); bindInput(UI.w,'size'); bindInput(UI.h,'size');
bindInput(UI.r,'rot'); bindInput(UI.o,'op'); bindInput(UI.blend,'blend');
bindInput(UI.fill,'fill'); bindInput(UI.stroke,'stroke'); bindInput(UI.strokeW,'strokeW'); bindInput(UI.rx,'rx');
bindInput(UI.fillPaint,'fillPaint'); bindInput(UI.strokePaint,'strokePaint');
bindInput(UI.font,'font'); bindInput(UI.fontSize,'fontSize');
bindInput(UI.textColor,'textColor');

document.querySelectorAll('#alignSeg .seg-opt').forEach(btn =&gt; {
  btn.addEventListener('click', () =&gt; {
    document.querySelectorAll('#alignSeg .seg-opt').forEach(b =&gt; b.classList.remove('on'));
    btn.classList.add('on');
    const obj = activeObj();
    if(obj) { obj.set({ textAlign: btn.dataset.val }); canvas.requestRenderAll(); }
  });
});

['selection:created','selection:updated','selection:cleared'].forEach(ev =&gt; canvas.on(ev, () =&gt; {
  if (ev === 'selection:cleared') clearSmartOverlayState();
  else clearSmartOverlayState({ keepMeasurements:isAltMeasureDown });
  const active = canvas.getActiveObject();
  if (!artboardMode &amp;&amp; active &amp;&amp; !isGuide(active)) setArtboardsEditable(false);
  refreshProps(); refreshLayers();
  if (ev === 'selection:cleared' &amp;&amp; bezierEditor.enabled) finalizeBezierEditor();
  if ((ev === 'selection:created' || ev === 'selection:updated') &amp;&amp; activeTool === 'direct-select') {
    const obj = activeObj();
    if (pathIsBezierEditable(obj)) attachBezierEditor(obj, { handlesActive:true, modelKey:resolveBezierModelKey(obj) });
  }
  ensureBezierNodePanel();
  refreshBezierSelectionFrame(activeObj());
  refreshAlignmentAssist();
}));

// ─── Layers ──────────────────────────────────────────────
const typeIcons = {
  textbox:'type', text:'type', 'i-text':'type',
  rect:'square', circle:'circle', ellipse:'circle-ellipsis', line:'slash', image:'image', group:'layers'
};
const blendModes = ['source-over','multiply','screen','overlay','darken','lighten','color-dodge','color-burn','difference','exclusion'];
let layerFolders = ['Geral'];
let draggingLayerId = null;

function ensureFoldersForObjects(objs){
  objs.forEach(obj =&gt; {
    if(!obj.dataFolder) obj.dataFolder = 'Geral';
    if(!layerFolders.includes(obj.dataFolder)) layerFolders.push(obj.dataFolder);
  });
}

function renderFolderChips(){
  const root = $('folderList');
  if(!root) return;
  root.innerHTML = layerFolders.map(name =&gt; `&lt;span class="folder-chip"&gt;📁 ${name}&lt;/span&gt;`).join('');
}

function moveLayerByDisplayIndex(obj, displayIndex){
  const objects = canvas.getObjects().filter(o=&gt;!isGuide(o));
  const targetIndex = Math.max(0, Math.min(objects.length - 1, objects.length - 1 - displayIndex));
  canvas.moveTo(obj, targetIndex);
  canvas.requestRenderAll();
}

function applyClipMask(){
  const sel = canvas.getActiveObject();
  if(!sel || sel.type !== 'activeSelection' || sel._objects.length &lt; 2){
    setStatus('Selecione 2 objetos para criar clip mask.');
    return;
  }
  const objs = sel._objects.slice();
  const mask = objs[0];
  const target = objs[1];
  mask.clone(clone =&gt; {
    clone.absolutePositioned = true;
    clone.set({ left: mask.left, top: mask.top, angle: mask.angle, scaleX: mask.scaleX, scaleY: mask.scaleY, originX: mask.originX, originY: mask.originY });
    target.clipPath = clone;
    canvas.remove(mask);
    canvas.discardActiveObject();
    canvas.setActiveObject(target);
    canvas.requestRenderAll();
    refreshLayers();
    setStatus('Clip mask aplicado');
  });
}

function releaseClipMask(){
  const obj = activeObj();
  if(!obj || !obj.clipPath){
    setStatus('Selecione um objeto com clip mask.');
    return;
  }
  obj.clipPath = null;
  canvas.requestRenderAll();
  refreshLayers();
  setStatus('Clip mask removido');
}

function createLayerFolder(){
  const name = prompt('Nome da pasta de camadas:');
  if(!name) return;
  const clean = name.trim();
  if(!clean) return;
  if(layerFolders.includes(clean)) { setStatus('Essa pasta já existe.'); return; }
  layerFolders.push(clean);
  renderFolderChips();
  refreshLayers();
  setStatus('Pasta criada');
}

function renameLayerObject(obj){
  if (!obj) return;
  const current = obj.dataName || (obj.text ? String(obj.text).slice(0,18) : obj.type);
  const next = prompt('Novo nome da camada:', current || 'Layer');
  if (!next || !next.trim()) return;
  obj.dataName = next.trim();
  canvas.requestRenderAll();
  refreshLayers();
  setStatus('Camada renomeada');
}

function toggleLayerVisibility(obj){
  if (!obj) return;
  const nextVisible = !(obj.visible !== false);
  obj.visible = nextVisible;
  obj.evented = nextVisible;
  obj.selectable = nextVisible &amp;&amp; activeTool !== 'text' &amp;&amp; activeTool !== 'bezier' &amp;&amp; activeTool !== 'bezier-v2';
  if (!nextVisible &amp;&amp; canvas.getActiveObject() === obj) canvas.discardActiveObject();
  canvas.requestRenderAll();
  refreshProps();
  refreshLayers();
}

function refreshLayers() {
  const list = $('layersList');
  const cnt = $('layerCount');
  if (!list) return;
  const objs = canvas.getObjects().filter(o=&gt;!isGuide(o) &amp;&amp; !o.isBezierEditorControl &amp;&amp; !o.isBezierOverlay).slice().reverse();
  ensureFoldersForObjects(objs);
  renderFolderChips();
  if (cnt) cnt.textContent = objs.length;
  const active = canvas.getActiveObject();
  list.innerHTML = '';
  if (!objs.length) {
    list.innerHTML = '&lt;div class="layer-empty"&gt;Sem objetos ainda&lt;/div&gt;';
    return;
  }

  objs.forEach((obj, i) =&gt; {
    const isAct = obj === active;
    const isVisible = obj.visible !== false;
    const name = String(obj.dataName || (obj.text ? obj.text.slice(0,18) : obj.type) || 'layer');
    const opacity = Math.round((obj.opacity??1)*100);
    const folder = String(obj.dataFolder || 'Geral');
    const visIcon = isVisible ? 'eye' : 'eye-off';

    const div = document.createElement('div');
    div.className = 'layer-item' + (isAct ? ' active' : '') + (isVisible ? '' : ' is-hidden');
    div.draggable = true;
    div.dataset.layerId = obj.__uid || (obj.__uid = 'ly_' + Math.random().toString(36).slice(2,9));
    div.innerHTML = `
      &lt;span class="layer-marker"&gt;&lt;/span&gt;
      &lt;div class="layer-main"&gt;
        &lt;div class="layer-name" title="${name}"&gt;${name}&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="layer-row-meta"&gt;
        &lt;div class="layer-meta"&gt;${opacity}%&lt;/div&gt;
        &lt;div class="layer-meta"&gt;${folder}&lt;/div&gt;
        &lt;button class="layer-vis-btn" type="button" title="${isVisible ? 'Ocultar camada' : 'Mostrar camada'}"&gt;
          &lt;i data-lucide="${visIcon}" data-size="12"&gt;&lt;/i&gt;
        &lt;/button&gt;
      &lt;/div&gt;`;

    const visBtn = div.querySelector('.layer-vis-btn');
    visBtn?.addEventListener('click', e =&gt; {
      e.stopPropagation();
      toggleLayerVisibility(obj);
    });

    div.addEventListener('click', () =&gt; {
      if (obj.visible === false) return;
      canvas.setActiveObject(obj);
      canvas.requestRenderAll();
      refreshProps();
      refreshLayers();
    });

    div.addEventListener('dblclick', e =&gt; {
      e.preventDefault();
      e.stopPropagation();
      renameLayerObject(obj);
    });

    div.addEventListener('dragstart', () =&gt; { draggingLayerId = div.dataset.layerId; });
    div.addEventListener('dragover', e =&gt; { e.preventDefault(); div.classList.add('drag-over'); });
    div.addEventListener('dragleave', () =&gt; div.classList.remove('drag-over'));
    div.addEventListener('drop', e =&gt; {
      e.preventDefault();
      div.classList.remove('drag-over');
      if(!draggingLayerId || draggingLayerId===div.dataset.layerId) return;
      const draggedObj = objs.find(o =&gt; o.__uid===draggingLayerId);
      if(!draggedObj) return;
      moveLayerByDisplayIndex(draggedObj, i);
      refreshLayers();
    });

    list.appendChild(div);
  });
  if(window.lucide?.createIcons) window.lucide.createIcons({attrs:{'stroke-width':1.9}});
}

let brandLibrary=[];
let draggedLibraryIndex = null;

function refreshLibrary(){
  const list=$('libraryList');
  const cnt=$('libCount');
  if(!list) return;
  if(cnt) cnt.textContent=brandLibrary.length;
  list.innerHTML='';
  if(!brandLibrary.length){
    list.innerHTML='&lt;div class="layer-empty"&gt;Sem itens de identidade&lt;/div&gt;';
    return;
  }
  brandLibrary.forEach((item,idx)=&gt;{
    const div=document.createElement('div');
    div.className='lib-item';
    const icon = item.kind==='logo' ? 'image' : item.kind==='color' ? 'droplets' : 'type';
    const meta = item.kind==='logo' ? 'Logo' : item.kind==='color' ? (item.color||'Cor') : ((item.font||'Fonte')+' • '+(item.size||16)+'px');
    div.draggable = true;
    const preview = item.kind==='logo' &amp;&amp; item.src ? `background-image:url('${item.src}')` : item.kind==='color' ? `background:${item.color||'#999'}` : 'background:linear-gradient(135deg, rgba(127,90,240,.35), rgba(44,182,125,.35))';
    div.innerHTML=`&lt;div class="lib-preview" style="${preview}"&gt;&lt;/div&gt;&lt;div class="lib-icon"&gt;&lt;i data-lucide="${icon}" data-size="13"&gt;&lt;/i&gt;&lt;/div&gt;&lt;div class="layer-name"&gt;${item.name||item.kind}&lt;/div&gt;&lt;div class="lib-meta"&gt;${meta}&lt;/div&gt;`;
    div.addEventListener('click',()=&gt;applyLibraryItem(idx));
    div.addEventListener('dragstart',()=&gt;{ draggedLibraryIndex = idx; });
    list.appendChild(div);
  });
  if(window.lucide?.createIcons) window.lucide.createIcons({attrs:{'stroke-width':1.9}});
}

function applyLibraryItem(idx){
  const item=brandLibrary[idx];
  if(!item) return;
  if(item.kind==='color'){
    const obj=activeObj();
    if(!obj){ setStatus('Selecione um objeto para aplicar a cor.'); return; }
    obj.set({fill:item.color||'#000000'});
    if(obj.type==='textbox'||obj.type==='text'||obj.type==='i-text'){
      if(UI.textColor) UI.textColor.value=item.color||'#000000';
    }else if(UI.fill){ UI.fill.value=item.color||'#000000'; }
    canvas.requestRenderAll();
    setStatus('Cor aplicada da biblioteca');
    return;
  }
  if(item.kind==='text-style'){
    const label = item.uppercase ? String(item.name||'Novo texto').toUpperCase() : (item.name||'Novo texto');
    const text = new fabric.Textbox(label, {
      left: artboard.left + Math.max(24, docW*0.1),
      top: artboard.top + Math.max(24, docH*0.1),
      width: Math.max(180, docW*0.4),
      fontFamily: item.font || 'Outfit',
      fontWeight: item.weight || 400,
      fontSize: item.size || 24,
      lineHeight: item.lineHeight || 1.2,
      charSpacing: (item.letterSpacing||0) * 50,
      fontStyle: item.italic ? 'italic' : 'normal',
      fill: '#ffffff',
      dataName: `Style: ${item.name||'Texto'}`
    });
    canvas.add(text); canvas.setActiveObject(text); canvas.requestRenderAll();
    refreshLayers(); refreshProps();
    setStatus('Estilo de texto adicionado da biblioteca');
    return;
  }
  if(item.kind==='logo' &amp;&amp; item.src){
    fabric.Image.fromURL(item.src, img=&gt;{
      if(!img) return;
      const maxW=docW*0.5, maxH=docH*0.35;
      const sc=Math.min(maxW/img.width, maxH/img.height, 1);
      img.set({
        left: artboard.left + docW/2 - (img.width*sc)/2,
        top: artboard.top + docH/2 - (img.height*sc)/2,
        scaleX: sc, scaleY: sc,
        dataName: item.name || 'Logo da biblioteca'
      });
      canvas.add(img); canvas.setActiveObject(img); canvas.requestRenderAll();
      refreshLayers(); refreshProps();
      setStatus('Logo inserido da biblioteca');
    }, {crossOrigin:'anonymous'});
  }
}

stageEl?.addEventListener('dragover', e =&gt; { if (draggedLibraryIndex==null) return; e.preventDefault(); });
stageEl?.addEventListener('drop', e =&gt; {
  if (draggedLibraryIndex==null) return;
  e.preventDefault();
  applyLibraryItem(draggedLibraryIndex);
  draggedLibraryIndex = null;
});

// ─── Context menu (canvas) ─────────────────────────────
(function initCanvasContextMenu(){
  const menu = $('canvasCtx');
  if(!menu || !canvas.upperCanvasEl) return;
  const close = () =&gt; menu.classList.remove('open');
  canvas.upperCanvasEl.addEventListener('contextmenu', e =&gt; {
    e.preventDefault();
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    menu.classList.add('open');
  });
  document.addEventListener('click', e =&gt; {
    if(!menu.contains(e.target)) close();
  });
  menu.addEventListener('click', e =&gt; {
    const act = e.target.closest('[data-act]')?.dataset.act;
    if(!act) return;
    if(act==='paste') pasteFromClipboard();
    if(act==='group') groupSelection();
    if(act==='ungroup') ungroupSelection();
    if(act==='front') bringForwardSelection();
    if(act==='back') sendBackwardSelection();
    if(act==='duplicate') duplicate();
    if(act==='delete') del();
    close();
  });
})();

// ─── Modal ───────────────────────────────────────────────
const modalBg = $('modalBg');
function openModal(title, html) {
  $('modalTitle').textContent = title;
  $('modalBody').innerHTML = html;
  modalBg.classList.add('open');
}
function closeModal() { modalBg.classList.remove('open'); $('modalBody').innerHTML=''; }
$('btnCloseModal')?.addEventListener('click', closeModal);
modalBg?.addEventListener('click', e =&gt; { if(e.target===modalBg) closeModal(); });

// ─── Export PNG ──────────────────────────────────────────
function exportPNG() {
  const current = getActiveArtboard();
  if (!current?.board) { setStatus('Nada para exportar'); return; }
  if (!current.exportEnabled) { setStatus('Este artboard está com exportação desativada.'); return; }

  const vt = canvas.viewportTransform;
  canvas.setViewportTransform([1,0,0,1,0,0]);
  const origZoom = zoom;
  const boardFill = current.board.fill;
  if (!current.background?.includeInExport) current.board.set({ fill:'rgba(0,0,0,0)' });

  const dataURL = canvas.toDataURL({
    format:'png', quality:1, multiplier:2,
    left: current.board.left,
    top: current.board.top,
    width: current.w,
    height: current.h
  });

  if (!current.background?.includeInExport) current.board.set({ fill:boardFill });
  canvas.setViewportTransform(vt);
  zoom = origZoom;
  const a = document.createElement('a');
  a.href = dataURL;
  a.download = `${current.board?.dataName || 'artboard'}.png`;
  a.click();
  setStatus('PNG exportado!');
}

function exportSVGToParent() {
  const current = getActiveArtboard();
  if (!canvas || !current?.board) {
    window.parent.postMessage({ type: 'geExportSVG', error: 'Sem conteúdo para exportar.' }, '*');
    return;
  }
  if (!current.exportEnabled) {
    window.parent.postMessage({ type: 'geExportSVG', error: 'Artboard com exportação desativada.' }, '*');
    return;
  }

  const boardFill = current.board.fill;
  if (!current.background?.includeInExport) current.board.set({ fill:'rgba(0,0,0,0)' });
  const svg = canvas.toSVG({
    suppressPreamble: false,
    width: current.w,
    height: current.h,
    viewBox: {
      x: current.board.left,
      y: current.board.top,
      width: current.w,
      height: current.h
    }
  });
  if (!current.background?.includeInExport) current.board.set({ fill:boardFill });
  window.parent.postMessage({ type: 'geExportSVG', svg, name: $('projectNameInline')?.value || '' }, '*');
}


function loadSVGFromParent(svgText) {
  const raw = String(svgText||'').trim();
  const keep = canvas.getObjects().filter(o =&gt; isGuide(o));
  canvas.getObjects().forEach(o =&gt; canvas.remove(o));
  keep.forEach(o =&gt; canvas.add(o));

  if (!raw) {
    canvas.requestRenderAll();
    setStatus('Arquivo novo pronto para edição');
    return;
  }

  // Detecta dimensões do SVG salvo para evitar abrir em uma prancheta padrão incorreta
  try {
    const doc = new DOMParser().parseFromString(raw, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if (svg) {
      let w = Number((svg.getAttribute('width')||'').replace(/[^\d.]/g,''));
      let h = Number((svg.getAttribute('height')||'').replace(/[^\d.]/g,''));
      const vb = (svg.getAttribute('viewBox')||'').trim().split(/\s+/).map(Number);
      if ((!w || !h) &amp;&amp; vb.length===4 &amp;&amp; vb.every(Number.isFinite)) {
        w = vb[2]; h = vb[3];
      }
      if (w&gt;0 &amp;&amp; h&gt;0) setArtboardSize(w, h);
    }
  } catch(_err) {}

  fabric.loadSVGFromString(raw, (objects) =&gt; {
    if (!objects || !objects.length) {
      canvas.requestRenderAll();
      setStatus('Não foi possível carregar SVG anterior');
      return;
    }

    const parsed = new DOMParser().parseFromString(raw, 'image/svg+xml');
    const root = parsed.querySelector('svg');
    const vb = (root?.getAttribute('viewBox') || '').trim().split(/\s+/).map(Number);
    const vbX = (vb.length === 4 &amp;&amp; Number.isFinite(vb[0])) ? vb[0] : 0;
    const vbY = (vb.length === 4 &amp;&amp; Number.isFinite(vb[1])) ? vb[1] : 0;

    objects.forEach(o =&gt; {
      o.set({
        left: (o.left||0) - vbX,
        top: (o.top||0) - vbY,
        selectable:true,
        evented:true,
        excludeFromExport:false
      });
      o.setCoords();
      canvas.add(o);
    });

    canvas.requestRenderAll();
    fitToArtboard();
    refreshLayers();
    refreshProps();
    setStatus('Aplicação carregada para edição');
  });
}

// ─── JSON save / load ─────────────────────────────────────
function saveJSON() {
  const json = JSON.stringify(canvas.toJSON(SERIALIZE_PROPS), null, 2);
  openModal('Salvar JSON', `
    &lt;textarea class="modal-textarea"&gt;${json}&lt;/textarea&gt;
    &lt;div style="display:flex;gap:8px;margin-top:12px"&gt;
      &lt;button class="tbtn accent" onclick="navigator.clipboard.writeText(document.querySelector('.modal-textarea').value).then(()=&gt;{this.textContent='Copiado!';setTimeout(()=&gt;{this.textContent='Copiar'},2000)})" style="flex:1;justify-content:center;height:36px"&gt;Copiar&lt;/button&gt;
      &lt;button class="tbtn" onclick="closeModal()" style="flex:1;justify-content:center;height:36px"&gt;Fechar&lt;/button&gt;
    &lt;/div&gt;
  `);
}

function loadJSON() {
  openModal('Carregar JSON', `
    &lt;p style="font-size:12px;color:var(--ink2);margin-bottom:10px;font-family:var(--mono)"&gt;Cole o JSON abaixo:&lt;/p&gt;
    &lt;textarea class="modal-textarea" id="jsonInput" placeholder='{"version":"5.3.0","objects":[...]}'&gt;&lt;/textarea&gt;
    &lt;div style="display:flex;gap:8px;margin-top:12px"&gt;
      &lt;button class="tbtn accent" onclick="
        try{
          const json=JSON.parse(document.getElementById('jsonInput').value);
          canvas.loadFromJSON(json,()=&gt;{refreshObjectCoords();canvas.getObjects().forEach(o=&gt;{if(pathIsBezierEditable(o))trackPathPosition(o);});canvas.requestRenderAll();refreshLayers();refreshProps();setStatus('JSON carregado')});
          closeModal();
        }catch(e){alert('JSON inválido')}
      " style="flex:1;justify-content:center;height:36px"&gt;Carregar&lt;/button&gt;
      &lt;button class="tbtn" onclick="closeModal()" style="flex:1;justify-content:center;height:36px"&gt;Cancelar&lt;/button&gt;
    &lt;/div&gt;
  `);
}

// ─── Upload image ─────────────────────────────────────────
$('fileInput')?.addEventListener('change', e =&gt; {
  const files = Array.from(e.target.files||[]);
  files.forEach(importExternalFile);
  e.target.value = '';
});

window.addEventListener('paste', e =&gt; {
  const items = Array.from(e.clipboardData?.items || []);
  let used = false;
  items.forEach(it =&gt; {
    if (it.kind === 'file') {
      const f = it.getAsFile();
      if (f) { importExternalFile(f); used = true; }
    }
    if (it.kind === 'string' &amp;&amp; it.type === 'text/plain') {
      it.getAsString(txt =&gt; {
        const s = String(txt||'').trim();
        if (s.startsWith('&lt;svg') || s.includes('&lt;svg')) { loadSVGFromParent(s); }
      });
    }
  });
  if (used) e.preventDefault();
});


async function pasteFromClipboard() {
  if (!navigator.clipboard?.read) {
    setStatus('Menu de colar indisponível. Use Ctrl+V no workspace.');
    return;
  }
  try {
    const clipItems = await navigator.clipboard.read();
    let imported = false;
    for (const clipItem of clipItems) {
      const pngType = clipItem.types.find(t =&gt; t.startsWith('image/'));
      if (pngType) {
        const blob = await clipItem.getType(pngType);
        const file = new File([blob], `clipboard.${pngType.split('/')[1] || 'png'}`, { type: pngType });
        importExternalFile(file);
        imported = true;
        continue;
      }
      if (clipItem.types.includes('text/plain')) {
        const txtBlob = await clipItem.getType('text/plain');
        const txt = (await txtBlob.text()).trim();
        if (txt.startsWith('&lt;svg') || txt.includes('&lt;svg')) {
          loadSVGFromParent(txt);
          imported = true;
        }
      }
    }
    if (!imported) setStatus('Nada compatível para colar.');
  } catch (err) {
    setStatus('Permita acesso à área de transferência ou use Ctrl+V.');
  }
}

// ─── Artboard container behavior ───────────────────────────
canvas.on('object:moving', opt =&gt; {
  const obj = opt.target;
  if (!obj) return;

  if (obj.isArtboardBoard) {
    const ab = getArtboardByBoard(obj);
    if (!ab) return;
    const last = ab.__lastPos || { left:obj.left, top:obj.top };
    const dx = (obj.left || 0) - (last.left || 0);
    const dy = (obj.top || 0) - (last.top || 0);
    ab.__lastPos = { left:obj.left, top:obj.top };
    if (dx || dy) {
      (ab.children || []).forEach(id =&gt; {
        const child = canvas.getObjects().find(o =&gt; o.id === id);
        if (!child) return;
        child.set({ left:(child.left || 0) + dx, top:(child.top || 0) + dy });
        child.setCoords();
      });
    }
    syncArtboardAuxGeometry(ab);
    refreshArtboardChildrenClipping(ab);
    updateArtboardPlusUI();
    canvas.requestRenderAll();
    return;
  }

  if (isGuide(obj)) return;
  if (pathIsBezierEditable(obj)) {
    syncPathVectorModelByDelta(obj);
    if (bezierEditor.enabled &amp;&amp; bezierEditor.path === obj) refreshBezierEditorControls();
  }
});

canvas.on('mouse:up', () =&gt; {
  canvas.getObjects().forEach(o =&gt; {
    if (o?.isArtboardBoard || isGuide(o) || o?.isBezierEditorControl || o?.isBezierOverlay) return;
    syncObjectArtboardMembership(o);
  });
  canvas.requestRenderAll();
});

canvas.on('object:modified', e =&gt; {
  const obj = e.target;
  if (!obj) return;
  if (obj.isArtboardBoard) {
    const ab = getArtboardByBoard(obj);
    if (!ab) return;
    syncArtboardAuxGeometry(ab);
    refreshArtboardChildrenClipping(ab);
    ab.__lastPos = { left:obj.left, top:obj.top };
    syncActiveArtboardRefs();
    updateArtboardPlusUI();
    return;
  }
  if (!isGuide(obj)) syncObjectArtboardMembership(obj);
});

// ─── Command menus (Arquivo / Editar / etc) ───────────────
const menuCatalog = {
  file: [
    {id:'file.new', label:'Novo documento', key:'Ctrl+N'},
    {id:'file.open', label:'Abrir', key:'Ctrl+O'},
    {id:'file.close', label:'Fechar'},
    {sep:true},
    {id:'file.save', label:'Salvar', key:'Ctrl+S'},
    {id:'file.saveAs', label:'Salvar como', key:'Ctrl+Shift+S'},
    {sep:true},
    {id:'file.exportPng', label:'Exportar PNG'},
    {id:'file.exportJpg', label:'Exportar JPG'},
    {id:'file.exportSvg', label:'Exportar SVG'},
    {id:'file.exportPdf', label:'Exportar PDF'},
    {sep:true},
    {id:'file.import', label:'Importar', key:'Ctrl+I'},
    {id:'file.document', label:'Configuração do documento'},
    {id:'file.preferences', label:'Preferências'}
  ],
  edit: [
    {id:'edit.undo', label:'Desfazer', key:'Ctrl+Z'},
    {id:'edit.redo', label:'Refazer', key:'Ctrl+Shift+Z'},
    {sep:true},
    {id:'edit.copy', label:'Copiar', key:'Ctrl+C'},
    {id:'edit.paste', label:'Colar', key:'Ctrl+V'},
    {id:'edit.pasteInPlace', label:'Colar no lugar'},
    {id:'edit.cut', label:'Recortar', key:'Ctrl+X'},
    {id:'edit.duplicate', label:'Duplicar', key:'Ctrl+D'},
    {id:'edit.delete', label:'Apagar', key:'Del'},
    {sep:true},
    {id:'edit.group', label:'Agrupar', key:'Ctrl+G'},
    {id:'edit.ungroup', label:'Desagrupar', key:'Ctrl+Shift+G'},
    {id:'edit.lock', label:'Bloquear'},
    {id:'edit.unlock', label:'Desbloquear'},
    {id:'edit.hide', label:'Ocultar'},
    {id:'edit.show', label:'Mostrar'}
  ],
  selection: [
    {id:'selection.normal', label:'Seleção normal'},
    {id:'selection.direct', label:'Seleção direta'},
    {id:'selection.selectAll', label:'Selecionar tudo', key:'Ctrl+A'},
    {id:'selection.deselectAll', label:'Desselecionar', key:'Esc'},
    {id:'selection.byColor', label:'Selecionar por cor'},
    {id:'selection.byLayer', label:'Selecionar por camada'},
    {id:'selection.similar', label:'Selecionar semelhantes'},
    {id:'selection.isolate', label:'Isolar grupo'},
    {id:'selection.lasso', label:'Seleção por laço'}
  ],
  create: [
    {id:'create.rect', label:'Retângulo'},
    {id:'create.ellipse', label:'Elipse'},
    {id:'create.polygon', label:'Polígono'},
    {id:'create.star', label:'Estrela'},
    {id:'create.line', label:'Linha'},
    {id:'create.pen', label:'Caneta'},
    {id:'create.pencil', label:'Lápis'},
    {id:'create.brush', label:'Pincel vetorial'},
    {id:'create.artText', label:'Texto artístico'},
    {id:'create.textBox', label:'Texto em área'},
    {id:'create.textOnPath', label:'Texto em caminho'},
    {id:'create.eyedropper', label:'Conta-gotas'},
    {id:'create.artboard', label:'Novo artboard'}
  ],
  transform: [
    {id:'transform.move', label:'Mover'},
    {id:'transform.rotate', label:'Rotacionar'},
    {id:'transform.scale', label:'Escalar'},
    {id:'transform.distort', label:'Distorcer'},
    {id:'transform.skew', label:'Inclinar (Skew)'},
    {id:'transform.flipH', label:'Espelhar horizontal'},
    {id:'transform.flipV', label:'Espelhar vertical'},
    {id:'transform.free', label:'Transformação livre'},
    {id:'transform.align', label:'Alinhar'},
    {id:'transform.distribute', label:'Distribuir'},
    {id:'transform.snapGrid', label:'Ajustar à grade'},
    {id:'transform.snapObjects', label:'Snap em objetos'}
  ],
  appearance: [
    {id:'appearance.fill', label:'Cor de preenchimento'},
    {id:'appearance.stroke', label:'Cor de contorno'},
    {id:'appearance.strokeWidth', label:'Espessura do traço'},
    {id:'appearance.strokeType', label:'Tipo de traço'},
    {id:'appearance.opacity', label:'Opacidade'},
    {id:'appearance.blend', label:'Modos de mesclagem'},
    {id:'appearance.gradient', label:'Gradiente'},
    {id:'appearance.mask', label:'Máscara'},
    {id:'appearance.clipMask', label:'Máscara de recorte'},
    {id:'appearance.effects', label:'Efeitos'}
  ],
  organize: [
    {id:'organize.front', label:'Trazer para frente'},
    {id:'organize.back', label:'Enviar para trás'},
    {id:'organize.byLayer', label:'Organizar por camada'},
    {id:'organize.newLayer', label:'Criar nova camada'},
    {id:'organize.groupLayer', label:'Agrupar por camada'},
    {id:'organize.rename', label:'Nomear objeto'}
  ],
  boolean: [
    {id:'boolean.union', label:'Unir'},
    {id:'boolean.subtract', label:'Subtrair'},
    {id:'boolean.intersect', label:'Interseção'},
    {id:'boolean.exclude', label:'Excluir'},
    {id:'boolean.divide', label:'Dividir'},
    {id:'boolean.trim', label:'Aparar'}
  ],
  text: [
    {id:'text.font', label:'Alterar fonte'},
    {id:'text.size', label:'Tamanho da fonte'},
    {id:'text.lineHeight', label:'Entrelinha'},
    {id:'text.kerning', label:'Kerning'},
    {id:'text.tracking', label:'Tracking'},
    {id:'text.toCurves', label:'Converter texto em curvas'},
    {id:'text.align', label:'Alinhar texto'},
    {id:'text.case', label:'Caixa alta/baixa'}
  ],
  view: [
    {id:'view.zoomIn', label:'Zoom in', key:'Ctrl++'},
    {id:'view.zoomOut', label:'Zoom out', key:'Ctrl+-'},
    {id:'view.fit', label:'Ajustar à tela'},
    {id:'view.fitSelection', label:'Ajustar à seleção'},
    {id:'view.grid', label:'Mostrar/ocultar grade'},
    {id:'view.guides', label:'Mostrar/ocultar guias'},
    {id:'view.nodes', label:'Mostrar nós'},
    {id:'view.outline', label:'Modo outline'},
    {id:'view.preview', label:'Modo preview'}
  ],
  advanced: [
    {id:'advanced.components', label:'Componentes / Símbolos'},
    {id:'advanced.autoLayout', label:'Auto Layout'},
    {id:'advanced.constraints', label:'Constraints'},
    {id:'advanced.vectorize', label:'Vetorização de imagem'},
    {id:'advanced.expandStroke', label:'Expandir traço'},
    {id:'advanced.pathfinder', label:'Pathfinder'},
    {id:'advanced.mesh', label:'Mesh tool'},
    {id:'advanced.warp', label:'Warp'}
  ]
};

const shortcutToCommand = new Map();
Object.values(menuCatalog).flat().forEach(item =&gt; {
  if (!item || item.sep || !item.key) return;
  shortcutToCommand.set(item.key.toLowerCase(), item.id);
});

function registerMenu(rootId, panelId, items){
  const root = $(rootId), panel = $(panelId);
  if(!root || !panel) return;
  panel.innerHTML = items.map(item =&gt; {
    if (item.sep) return '&lt;div class="menu-cmd-sep"&gt;&lt;/div&gt;';
    const key = item.key ? `&lt;span class="k"&gt;${item.key}&lt;/span&gt;` : '&lt;span class="k"&gt;&lt;/span&gt;';
    return `&lt;div class="menu-cmd" data-cmd="${item.id}"&gt;&lt;span&gt;${item.label}&lt;/span&gt;${key}&lt;/div&gt;`;
  }).join('');

  const btn = root.querySelector('.menu-item-btn');
  const closeAll = () =&gt; document.querySelectorAll('.menu-dd.open').forEach(n =&gt; n.classList.remove('open'));
  btn?.addEventListener('click', e =&gt; {
    e.stopPropagation();
    const willOpen = !root.classList.contains('open');
    closeAll();
    if (willOpen) root.classList.add('open');
  });
  panel.addEventListener('click', e =&gt; {
    const cmd = e.target.closest('[data-cmd]')?.dataset.cmd;
    if (!cmd) return;
    executeMenuCommand(cmd);
    closeAll();
  });
}

function notifyTodo(label){
  setStatus(`${label}: em breve.`);
}

function selectAllObjects(){
  const items = canvas.getObjects().filter(o =&gt; !isGuide(o));
  if (!items.length) return;
  canvas.setActiveObject(new fabric.ActiveSelection(items, { canvas }));
  canvas.requestRenderAll();
}

function flipSelection(axis='x'){
  const obj = activeObj();
  if(!obj) return;
  if (axis === 'x') obj.set({ flipX: !obj.flipX });
  else obj.set({ flipY: !obj.flipY });
  obj.setCoords();
  canvas.requestRenderAll();
}

function openDocumentSettingsModal(){
  openModal('Configuração do documento', `
    &lt;div class="panel-section" style="margin-bottom:0"&gt;
      &lt;div class="field-row"&gt;
        &lt;div class="field-item"&gt;
          &lt;div class="field-label"&gt;W px&lt;/div&gt;
          &lt;input class="field-input" id="docModalW" type="number" value="${Math.round(docW)}" min="200" max="5000"&gt;
        &lt;/div&gt;
        &lt;div class="field-item"&gt;
          &lt;div class="field-label"&gt;H px&lt;/div&gt;
          &lt;input class="field-input" id="docModalH" type="number" value="${Math.round(docH)}" min="200" max="5000"&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="field-row one"&gt;
        &lt;div class="field-item"&gt;
          &lt;div class="field-label"&gt;Mesa&lt;/div&gt;
          &lt;input class="field-input" id="docModalBg" type="color" value="${$('docBg')?.value || '#0f1626'}"&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="field-row one"&gt;
        &lt;button class="tbtn" id="docModalApply" style="width:100%;justify-content:center;height:32px"&gt;Aplicar&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `);
  $('docModalApply')?.addEventListener('click', () =&gt; {
    const w = parseFloat($('docModalW')?.value || docW);
    const h = parseFloat($('docModalH')?.value || docH);
    const bg = $('docModalBg')?.value || '#0f1626';
    setArtboardSize(w, h);
    setDeskBg(bg);
    closeModal();
  });
}

function executeMenuCommand(cmdId){
  const map = {
    'file.new': () =&gt; loadSVGFromParent(''),
    'file.open': () =&gt; $('fileInput')?.click(),
    'file.close': () =&gt; loadSVGFromParent(''),
    'file.save': exportSVGToParent,
    'file.saveAs': exportSVGToParent,
    'file.exportPng': exportPNG,
    'file.exportJpg': () =&gt; notifyTodo('Exportar JPG'),
    'file.exportSvg': exportSVGToParent,
    'file.exportPdf': () =&gt; notifyTodo('Exportar PDF'),
    'file.import': () =&gt; $('fileInput')?.click(),
    'file.document': () =&gt; openDocumentSettingsModal(),
    'file.preferences': () =&gt; notifyTodo('Preferências'),

    'edit.undo': undo,
    'edit.redo': redo,
    'edit.copy': () =&gt; document.execCommand?.('copy') || setStatus('Use Ctrl+C para copiar.'),
    'edit.paste': pasteFromClipboard,
    'edit.pasteInPlace': pasteFromClipboard,
    'edit.cut': () =&gt; { document.execCommand?.('copy'); del(); },
    'edit.duplicate': duplicate,
    'edit.delete': del,
    'edit.group': groupSelection,
    'edit.ungroup': ungroupSelection,
    'edit.lock': () =&gt; notifyTodo('Bloquear'),
    'edit.unlock': () =&gt; notifyTodo('Desbloquear'),
    'edit.hide': () =&gt; notifyTodo('Ocultar'),
    'edit.show': () =&gt; notifyTodo('Mostrar'),

    'selection.normal': () =&gt; setActiveTool('select'),
    'selection.direct': () =&gt; setActiveTool('direct-select'),
    'selection.selectAll': selectAllObjects,
    'selection.deselectAll': () =&gt; { canvas.discardActiveObject(); canvas.requestRenderAll(); },
    'selection.byColor': () =&gt; notifyTodo('Selecionar por cor'),
    'selection.byLayer': () =&gt; notifyTodo('Selecionar por camada'),
    'selection.similar': () =&gt; notifyTodo('Selecionar semelhantes'),
    'selection.isolate': () =&gt; notifyTodo('Isolar grupo'),
    'selection.lasso': () =&gt; notifyTodo('Seleção por laço'),

    'create.rect': addRect,
    'create.ellipse': addCircle,
    'create.polygon': () =&gt; notifyTodo('Polígono'),
    'create.star': () =&gt; notifyTodo('Estrela'),
    'create.line': addLine,
    'create.pen': addBezier,
    'create.artboard': () =&gt; $('btnNewArtboard')?.click(),
    'create.pencil': () =&gt; notifyTodo('Lápis'),
    'create.brush': () =&gt; notifyTodo('Pincel vetorial'),
    'create.artText': () =&gt; setActiveTool('text'),
    'create.textBox': () =&gt; setActiveTool('text'),
    'create.textOnPath': () =&gt; notifyTodo('Texto em caminho'),
    'create.eyedropper': () =&gt; notifyTodo('Conta-gotas'),

    'transform.move': () =&gt; setActiveTool('move'),
    'transform.rotate': () =&gt; notifyTodo('Rotacionar'),
    'transform.scale': () =&gt; notifyTodo('Escalar'),
    'transform.distort': () =&gt; notifyTodo('Distorcer'),
    'transform.skew': () =&gt; notifyTodo('Skew'),
    'transform.flipH': () =&gt; flipSelection('x'),
    'transform.flipV': () =&gt; flipSelection('y'),
    'transform.free': () =&gt; notifyTodo('Transformação livre'),
    'transform.align': () =&gt; notifyTodo('Alinhar'),
    'transform.distribute': () =&gt; notifyTodo('Distribuir'),
    'transform.snapGrid': () =&gt; notifyTodo('Ajustar à grade'),
    'transform.snapObjects': () =&gt; notifyTodo('Snap em objetos'),

    'appearance.fill': () =&gt; notifyTodo('Cor de preenchimento'),
    'appearance.stroke': () =&gt; notifyTodo('Cor de contorno'),
    'appearance.strokeWidth': () =&gt; notifyTodo('Espessura do traço'),
    'appearance.strokeType': () =&gt; notifyTodo('Tipo de traço'),
    'appearance.opacity': () =&gt; notifyTodo('Opacidade'),
    'appearance.blend': () =&gt; notifyTodo('Modos de mesclagem'),
    'appearance.gradient': () =&gt; notifyTodo('Gradiente'),
    'appearance.mask': () =&gt; notifyTodo('Máscara'),
    'appearance.clipMask': applyClipMask,
    'appearance.effects': () =&gt; notifyTodo('Efeitos'),

    'organize.front': bringForwardSelection,
    'organize.back': sendBackwardSelection,
    'organize.byLayer': () =&gt; notifyTodo('Organizar por camada'),
    'organize.newLayer': addLayer,
    'organize.groupLayer': createLayerFolder,
    'organize.rename': () =&gt; notifyTodo('Nomear objeto'),

    'boolean.union': () =&gt; notifyTodo('Boolean: Unir'),
    'boolean.subtract': () =&gt; notifyTodo('Boolean: Subtrair'),
    'boolean.intersect': () =&gt; notifyTodo('Boolean: Interseção'),
    'boolean.exclude': () =&gt; notifyTodo('Boolean: Excluir'),
    'boolean.divide': () =&gt; notifyTodo('Boolean: Dividir'),
    'boolean.trim': () =&gt; notifyTodo('Boolean: Aparar'),

    'text.font': () =&gt; notifyTodo('Alterar fonte'),
    'text.size': () =&gt; notifyTodo('Tamanho da fonte'),
    'text.lineHeight': () =&gt; notifyTodo('Entrelinha'),
    'text.kerning': () =&gt; notifyTodo('Kerning'),
    'text.tracking': () =&gt; notifyTodo('Tracking'),
    'text.toCurves': () =&gt; notifyTodo('Converter texto em curvas'),
    'text.align': () =&gt; notifyTodo('Alinhar texto'),
    'text.case': () =&gt; notifyTodo('Caixa alta/baixa'),

    'view.zoomIn': () =&gt; $('btnZoomIn')?.click(),
    'view.zoomOut': () =&gt; $('btnZoomOut')?.click(),
    'view.fit': fitToArtboard,
    'view.fitSelection': () =&gt; notifyTodo('Ajustar à seleção'),
    'view.grid': () =&gt; notifyTodo('Grade'),
    'view.guides': () =&gt; notifyTodo('Guias'),
    'view.nodes': () =&gt; notifyTodo('Mostrar nós'),
    'view.outline': () =&gt; notifyTodo('Modo outline'),
    'view.preview': () =&gt; notifyTodo('Modo preview'),

    'advanced.components': () =&gt; notifyTodo('Componentes / Símbolos'),
    'advanced.autoLayout': () =&gt; notifyTodo('Auto Layout'),
    'advanced.constraints': () =&gt; notifyTodo('Constraints'),
    'advanced.vectorize': () =&gt; notifyTodo('Vetorização de imagem'),
    'advanced.expandStroke': () =&gt; notifyTodo('Expandir traço'),
    'advanced.pathfinder': () =&gt; notifyTodo('Pathfinder'),
    'advanced.mesh': () =&gt; notifyTodo('Mesh tool'),
    'advanced.warp': () =&gt; notifyTodo('Warp')
  };
  const fn = map[cmdId];
  if (typeof fn === 'function') fn();
  else notifyTodo(cmdId);
}

function normalizeShortcutKey(e){
  const parts = [];
  if (e.ctrlKey || e.metaKey) parts.push('ctrl');
  if (e.shiftKey) parts.push('shift');
  if (e.altKey) parts.push('alt');
  const k = (e.key || '').toLowerCase();
  if (!k) return '';
  const key = k === 'escape' ? 'esc' : k;
  parts.push(key);
  return parts.join('+');
}

(function initCommandMenus(){
  registerMenu('menuFileRoot','menuFilePanel',menuCatalog.file);
  registerMenu('menuEditRoot','menuEditPanel',menuCatalog.edit);
  registerMenu('menuSelectRoot','menuSelectPanel',menuCatalog.selection);
  registerMenu('menuCreateRoot','menuCreatePanel',menuCatalog.create);
  registerMenu('menuTransformRoot','menuTransformPanel',menuCatalog.transform);
  registerMenu('menuAppearanceRoot','menuAppearancePanel',menuCatalog.appearance);
  registerMenu('menuOrganizeRoot','menuOrganizePanel',menuCatalog.organize);
  registerMenu('menuBooleanRoot','menuBooleanPanel',menuCatalog.boolean);
  registerMenu('menuTextRoot','menuTextPanel',menuCatalog.text);
  registerMenu('menuViewRoot','menuViewPanel',menuCatalog.view);
  registerMenu('menuAdvancedRoot','menuAdvancedPanel',menuCatalog.advanced);

  document.addEventListener('click', () =&gt; {
    document.querySelectorAll('.menu-dd.open').forEach(n =&gt; n.classList.remove('open'));
  });

  window.addEventListener('keydown', e =&gt; {
    if (e.target?.matches?.('input,textarea,select,[contenteditable="true"]')) return;
    const cmd = shortcutToCommand.get(normalizeShortcutKey(e));
    if (!cmd) return;
    e.preventDefault();
    executeMenuCommand(cmd);
  }, {passive:false});
})();


function setBezierSubmenuMode(_enabled){
  const labels = { btnToolVector:'Vetor', btnToolMove:'Mover', btnToolLasso:'Laço', btnToolPaint:'Pintar', btnToolCurve:'Curvar', btnToolCut:'Cortar', btnToolMore:'Mais ▾' };
  Object.entries(labels).forEach(([id, txt]) =&gt; {
    const el = $(id);
    if (el) el.textContent = txt;
  });
}

function setActiveTool(tool){
  if (bezierEditor.enabled &amp;&amp; tool !== 'direct-select' &amp;&amp; tool !== 'bezier' &amp;&amp; tool !== 'bezier-v2' &amp;&amp; tool !== 'select') finalizeBezierEditor();
  activeTool = tool;
  const isText = tool === 'text';
  const isDirect = tool === 'direct-select';
  const isBezier = tool === 'bezier' || tool === 'bezier-v2';
  canvas.defaultCursor = isText ? 'text' : 'default';
  canvas.selection = !(isText || isDirect || isBezier);
  canvas.forEachObject(o =&gt; {
    if (isGuide(o) || o.isBezierEditorControl) return;
    o.selectable = !(isText || isBezier);
    if (pathIsBezierEditable(o)) o.hasBorders = tool !== 'select';
  });
  document.querySelectorAll('[data-tool]').forEach(btn =&gt; btn.classList.toggle('active', btn.dataset.tool===tool));
  $('btnSelect')?.classList.toggle('active', tool === 'select' || isDirect);
  $('btnLine')?.classList.toggle('active', tool === 'bezier-v2');
  $('btnSelectNormal')?.classList.toggle('active', tool === 'select');
  $('btnSelectDirect')?.classList.toggle('active', isDirect);
  $('selectToolSubmenu')?.classList.remove('open');
  const tb = $('floatingToolbar');
  if (tb) tb.classList.remove('show-bezier-submenu');
  setBezierSubmenuMode(false);
  if (tool === 'move' || tool === 'select') setStatus('Ferramenta mover ativa');
  if (isDirect) setStatus('Seleção direta ativa: selecione uma curva para editar alças.');
  if (tool === 'text') { setStatus('Texto: clique para artístico, arraste para caixa.'); focusTextPanel(true); }
  if ((tool === 'bezier' || tool === 'bezier-v2') &amp;&amp; vectorToolState.mode !== 'creating') setStatus('Bézier ativo: clique em segmento para adicionar nó, clique em nó para remover, clique fora para novo path.');
  ensureBezierNodePanel();
  canvas.requestRenderAll();
}


(function initAppearanceGear(){
  const btn = $('btnAppearanceGear');
  const tabs = $('propTabs');
  btn?.addEventListener('click', e => {
    e.stopPropagation();
    const tab = tabs?.querySelector('[data-tab="aparencia"]');
    tab?.click();
    renderAppearancePanel();
  });

  $('btnAddFillLayer')?.addEventListener('click', () => {
    const obj = activeObj(); if(!obj) return;
    const ap = ensureAppearanceData(obj);
    const current = ap.fills[ap.fills.length-1] || { type:'solid', color:'#111111' };
    ap.fills.push({ ...current });
    applyAppearanceStack(obj);
    renderAppearancePanel();
    canvas.requestRenderAll(); snapshot();
  });

  $('btnAddStrokeLayer')?.addEventListener('click', () => {
    const obj = activeObj(); if(!obj) return;
    const ap = ensureAppearanceData(obj);
    const current = ap.strokes[ap.strokes.length-1] || { type:'solid', color:'#000000', width:Number(obj.strokeWidth||1) };
    ap.strokes.push({ ...current });
    applyAppearanceStack(obj);
    renderAppearancePanel();
    canvas.requestRenderAll(); snapshot();
  });

  document.addEventListener('input', (e) => {
    const obj = activeObj(); if(!obj) return;
    const ap = ensureAppearanceData(obj);
    const t = e.target;
    if (t.matches('.appearance-fill-color')) {
      const i = Number(t.dataset.idx); if (ap.fills[i]) ap.fills[i].color = t.value;
      applyAppearanceStack(obj); canvas.requestRenderAll();
    }
    if (t.matches('.appearance-stroke-color')) {
      const i = Number(t.dataset.idx); if (ap.strokes[i]) ap.strokes[i].color = t.value;
      applyAppearanceStack(obj); canvas.requestRenderAll();
    }
    if (t.matches('.appearance-stroke-width')) {
      const i = Number(t.dataset.idx); if (ap.strokes[i]) ap.strokes[i].width = Number(t.value||0);
      applyAppearanceStack(obj); canvas.requestRenderAll();
    }
  });

  document.addEventListener('click', (e) => {
    const obj = activeObj(); if(!obj) return;
    const ap = ensureAppearanceData(obj);
    const t = e.target;
    if (t.matches('.appearance-fill-del')) {
      const i = Number(t.dataset.idx);
      if (ap.fills.length > 1) ap.fills.splice(i, 1);
      applyAppearanceStack(obj); renderAppearancePanel(); canvas.requestRenderAll(); snapshot();
    }
    if (t.matches('.appearance-stroke-del')) {
      const i = Number(t.dataset.idx);
      if (ap.strokes.length > 1) ap.strokes.splice(i, 1);
      applyAppearanceStack(obj); renderAppearancePanel(); canvas.requestRenderAll(); snapshot();
    }
  });
})();

// ─── Floating typography panel ──────────────────────────
(function initTextFloatPanel(){
  const panel = $('textFloatPanel');
  if(!panel) return;
  $('btnTypographyGear')?.addEventListener('click', (e)=&gt;{
    e.stopPropagation();
    panel.classList.toggle('open');
    focusTextPanel(true);
    syncFloatingTextPanel();
  });
  $('btnCloseTextFloat')?.addEventListener('click', ()=&gt; panel.classList.remove('open'));
  document.addEventListener('click', e =&gt; {
    if(!panel.classList.contains('open')) return;
    if(panel.contains(e.target) || e.target.id==='btnTypographyGear') return;
    panel.classList.remove('open');
  });
  document.querySelectorAll('[data-tf-tab]').forEach(btn =&gt; {
    btn.addEventListener('click', () =&gt; {
      document.querySelectorAll('[data-tf-tab]').forEach(b=&gt;b.classList.remove('active'));
      btn.classList.add('active');
      const key=btn.dataset.tfTab;
      panel.querySelectorAll('[data-pane]').forEach(p=&gt;p.classList.toggle('active', p.dataset.pane===key));
    });
  });

  const applyText = (fn)=&gt;{
    const obj = activeObj();
    if(!isTextObject(obj)) { setStatus('Selecione um texto para editar.'); return; }
    fn(obj);
    syncTextStyleRender(obj);
    canvas.requestRenderAll();
    refreshProps();
  };
  $('tfFontSize')?.addEventListener('input', ()=&gt; applyText(obj=&gt;obj.set({fontSize: clamp(Number($('tfFontSize').value)||16,6,512)})));
  $('tfColor')?.addEventListener('input', ()=&gt; applyText(obj=&gt;obj.set({fill:$('tfColor').value||obj.fill})));
  $('tfLineHeight')?.addEventListener('input', ()=&gt; applyText(obj=&gt;obj.set({lineHeight: clamp(Number($('tfLineHeight').value)||1.2,0.6,4)})));
  $('tfLetterSpacing')?.addEventListener('input', ()=&gt; applyText(obj=&gt;obj.set({charSpacing: (Number($('tfLetterSpacing').value)||0)*50})));
  $('tfWeight')?.addEventListener('change', ()=&gt; applyText(obj=&gt;obj.set({fontWeight: Number($('tfWeight').value)||400})));
  $('tfStyle')?.addEventListener('change', ()=&gt; applyText(obj=&gt;obj.set({fontStyle: $('tfStyle').value||'normal'})));
  document.querySelectorAll('#tfAlignSeg .seg-opt').forEach(btn =&gt; {
    btn.addEventListener('click', ()=&gt; applyText(obj=&gt;obj.set({textAlign: btn.dataset.val||'left'})));
  });
  $('tfUnderline')?.addEventListener('click', ()=&gt; applyText(obj=&gt;obj.set({underline: !obj.underline})));
  $('tfStrike')?.addEventListener('click', ()=&gt; applyText(obj=&gt;obj.set({linethrough: !obj.linethrough})));
  $('tfUppercase')?.addEventListener('click', ()=&gt; applyText(obj=&gt;obj.text &amp;&amp; obj.set({text: String(obj.text).toUpperCase()})));
  $('tfLowercase')?.addEventListener('click', ()=&gt; applyText(obj=&gt;obj.text &amp;&amp; obj.set({text: String(obj.text).toLowerCase()})));
})();

// ─── Bind toolbar buttons ─────────────────────────────────
$('btnSelect')?.addEventListener('click', (e) =&gt; {
  e.stopPropagation();
  if (activeTool === 'select' || activeTool === 'direct-select') {
    $('selectToolSubmenu')?.classList.toggle('open');
    return;
  }
  setActiveTool('select');
});
$('btnSelectNormal')?.addEventListener('click', () =&gt; setActiveTool('select'));
$('btnSelectDirect')?.addEventListener('click', () =&gt; setActiveTool('direct-select'));
document.addEventListener('click', e =&gt; {
  const sub = $('selectToolSubmenu');
  if (!sub) return;
  if (sub.contains(e.target) || $('btnSelect')?.contains(e.target)) return;
  sub.classList.remove('open');
});
$('btnToolVector')?.addEventListener('click', () =&gt; {
  if (activeTool === 'bezier' || activeTool === 'bezier-v2' || vectorToolState.mode === 'creating') return startBezierCreation({ modelKey:getActiveBezierModelKey() });
  setActiveTool('select');
});
$('btnToolMove')?.addEventListener('click', () =&gt; setActiveTool('move'));
$('btnTextTool')?.addEventListener('click', () =&gt; setActiveTool('text'));
$('btnRect')?.addEventListener('click', () =&gt; { setActiveTool('select'); addRect(); });
$('btnCircle')?.addEventListener('click', () =&gt; { setActiveTool('select'); addCircle(); });
$('btnCreateLayer')?.addEventListener('click', addLayer);
$('btnLine')?.addEventListener('click', () =&gt; { if (ENABLE_BEZIER_V2) addBezierV2(); else { setActiveTool('select'); addLine(); } });
$('btnBezier')?.addEventListener('click', () =&gt; addBezier());
$('btnArtboardTool')?.addEventListener('click', () =&gt; {
  artboardMode = !artboardMode;
  $('btnArtboardTool')?.classList.toggle('accent', artboardMode);
  setArtboardsEditable(artboardMode);
  updateArtboardPlusUI();
  canvas.requestRenderAll();
  setStatus(artboardMode ? 'Modo Artboard ativo: arraste para criar.' : 'Modo Artboard desativado.');
});
$('btnImportFile')?.addEventListener('click', () =&gt; $('fileInput')?.click());
$('btnNewArtboard')?.addEventListener('click', () =&gt; {
  const current = getActiveArtboard();
  if (!current) {
    createArtboard();
    fitToArtboard();
    setStatus('Artboard criado.');
    return;
  }
  addAdjacentArtboard('right');
  setStatus('Novo artboard criado à direita.');
});
$('btnToolLasso')?.addEventListener('click', () =&gt; setStatus('Laço: em breve.'));
$('btnToolPaint')?.addEventListener('click', () =&gt; setStatus('Pintar: em breve.'));
$('btnToolCurve')?.addEventListener('click', () =&gt; { setActiveTool('direct-select'); setStatus('Curvar/PCE ativo: selecione uma curva e um nó.'); ensureBezierNodePanel(); });
$('btnNodeCorner')?.addEventListener('click', () =&gt; applySelectedNodeType('corner'));
$('btnNodeSmooth')?.addEventListener('click', () =&gt; applySelectedNodeType('smooth'));
$('btnNodeMirrored')?.addEventListener('click', () =&gt; applySelectedNodeType('mirrored'));
$('btnNodeBreak')?.addEventListener('click', () =&gt; toggleSelectedNodeBreak());
$('btnToolCut')?.addEventListener('click', () =&gt; applyClipMask());
$('btnToolMore')?.addEventListener('click', () =&gt; setStatus('Mais ferramentas em breve.'));
$('btnFit')?.addEventListener('click', fitToArtboard);
$('btnZoomReset')?.addEventListener('click', fitToArtboard);
$('btnZoomIn')?.addEventListener('click', () =&gt; {
  const newZoom = clamp(zoom*1.15, 0.05, 10);
  canvas.zoomToPoint(new fabric.Point(canvas.getWidth()/2, canvas.getHeight()/2), newZoom);
  zoom = newZoom; updateZoomLabel();
  updateArtboardPlusUI();
});
$('btnZoomOut')?.addEventListener('click', () =&gt; {
  const newZoom = clamp(zoom/1.15, 0.05, 10);
  canvas.zoomToPoint(new fabric.Point(canvas.getWidth()/2, canvas.getHeight()/2), newZoom);
  zoom = newZoom; updateZoomLabel();
  updateArtboardPlusUI();
});
$('btnDelete')?.addEventListener('click', del);
$('btnDuplicate')?.addEventListener('click', duplicate);
$('btnUndo')?.addEventListener('click', undo);
$('btnRedo')?.addEventListener('click', redo);
$('btnExportPanelPng')?.addEventListener('click', exportPNG);
$('btnCloseEditor')?.addEventListener('click', () =&gt; window.parent.postMessage({ type: 'geCloseEditor' }, '*'));
$('btnSaveJson')?.addEventListener('click', saveJSON);
$('btnLoadJson')?.addEventListener('click', loadJSON);
$('btnApplyDoc')?.addEventListener('click', () =&gt; {
  const w = Number($('abW')?.value)||docW;
  const h = Number($('abH')?.value)||docH;
  setArtboardSize(w, h);
  setDeskBg($('docBg')?.value || deskBg);
  setDeskTheme($('deskTheme')?.value || 'nebula');
});
$('btnArtboardMode')?.addEventListener('click', () =&gt; {
  artboardMode = !artboardMode;
  $('btnArtboardMode').classList.toggle('accent', artboardMode);
  setArtboardsEditable(artboardMode);
  setStatus(artboardMode ? 'Modo Artboard ativo: arraste para criar.' : 'Modo Artboard desativado.');
  updateArtboardPlusUI();
  canvas.requestRenderAll();
});
$('btnAddArtTop')?.addEventListener('click', () =&gt; addAdjacentArtboard('top'));
$('btnAddArtRight')?.addEventListener('click', () =&gt; addAdjacentArtboard('right'));
$('btnAddArtBottom')?.addEventListener('click', () =&gt; addAdjacentArtboard('bottom'));
$('btnAddArtLeft')?.addEventListener('click', () =&gt; addAdjacentArtboard('left'));

const applyArtboardInspectorChanges = () =&gt; {
  const ab = getActiveArtboard();
  if (!ab) return;
  ab.clipContent = !!$('abClipContent')?.checked;
  ab.exportEnabled = !!$('abExportEnabled')?.checked;
  ab.background.enabled = !!$('abBgEnabled')?.checked;
  ab.background.locked = !!$('abBgLock')?.checked;
  ab.background.includeInExport = !!$('abBgExport')?.checked;
  if (!ab.background.locked &amp;&amp; $('abBgColor')?.value) ab.background.color = $('abBgColor').value;
  applyArtboardVisualState(ab);
  canvas.requestRenderAll();
};
['abClipContent','abExportEnabled','abBgEnabled','abBgLock','abBgExport','abBgColor'].forEach(id =&gt; {
  $(id)?.addEventListener('input', applyArtboardInspectorChanges);
  $(id)?.addEventListener('change', applyArtboardInspectorChanges);
});
$('btnApplyArtboardSize')?.addEventListener('click', () =&gt; {
  const w = Number($('abW')?.value)||docW;
  const h = Number($('abH')?.value)||docH;
  setArtboardSize(w, h);
  setStatus('Tamanho do artboard atualizado.');
});
$('btnCenterAll')?.addEventListener('click', () =&gt; {
  const obj = activeObj(); if(!obj||!artboard) return;
  obj.set({ left:artboard.left+docW/2-obj.getScaledWidth()/2, top:artboard.top+docH/2-obj.getScaledHeight()/2 });
  obj.setCoords(); canvas.requestRenderAll();
});
$('btnAlignLeft')?.addEventListener('click', () =&gt; alignSelection('left'));
$('btnAlignCenter')?.addEventListener('click', () =&gt; alignSelection('center'));
$('btnAlignRight')?.addEventListener('click', () =&gt; alignSelection('right'));
$('btnAlignTop')?.addEventListener('click', () =&gt; alignSelection('top'));
$('btnAlignBottom')?.addEventListener('click', () =&gt; alignSelection('bottom'));
$('btnAlignMiddle')?.addEventListener('click', () =&gt; alignSelection('middle'));
$('btnDistributeX')?.addEventListener('click', () =&gt; distributeSelection('x'));
$('btnDistributeY')?.addEventListener('click', () =&gt; distributeSelection('y'));
$('btnGroup')?.addEventListener('click', groupSelection);
$('btnUngroup')?.addEventListener('click', ungroupSelection);
$('btnClipMask')?.addEventListener('click', applyClipMask);
$('btnReleaseClip')?.addEventListener('click', releaseClipMask);
$('btnNewFolder')?.addEventListener('click', createLayerFolder);
$('btnLoadFont')?.addEventListener('click', loadGoogleFontForSelection);



// abas do painel direito
$('propTabs')?.addEventListener('click', e =&gt; {
  const tab = e.target.closest('.panel-tab');
  if(!tab) return;
  const key = tab.dataset.tab;
  document.querySelectorAll('.panel-tab').forEach(t =&gt; t.classList.toggle('active', t===tab));
  document.querySelectorAll('[data-tab-panel]').forEach(p =&gt; {
    p.style.display = p.dataset.tabPanel===key ? '' : 'none';
  });
});

function bindMirror(a,b,transformA=(v=&gt;v),transformB=(v=&gt;v)){
  const A=$(a), B=$(b);
  if(!A||!B) return;
  let lock=false;
  const sync = (from,to,fn) =&gt; {
    from.addEventListener('input',()=&gt;{
      if(lock) return;
      lock=true; to.value = fn(from.value); to.dispatchEvent(new Event('input',{bubbles:true})); lock=false;
    });
  };
  sync(A,B,transformA); sync(B,A,transformB);
}
bindMirror('pStroke','pStroke2');
bindMirror('pStrokeW','pStrokeW2',v=&gt;v,v=&gt;v);
bindMirror('pStrokeW2','pStrokeWRange2',v=&gt;v,v=&gt;v);
bindMirror('pBlend','pBlend2');

(function bindOpacityMirror(){
  const src=$('pO'), num=$('pOpacity2'), range=$('pOpacityRange2');
  if(!src||!num||!range) return;
  let lock=false;
  src.addEventListener('input',()=&gt;{
    if(lock) return; lock=true;
    const pct=Math.round((Number(src.value)||0)*100);
    num.value=String(pct); range.value=String(pct);
    lock=false;
  });
  const push=()=&gt;{
    if(lock) return; lock=true;
    const pct=Math.max(0,Math.min(100,Number(num.value||range.value)||0));
    num.value=String(Math.round(pct)); range.value=String(Math.round(pct));
    src.value=String((pct/100).toFixed(2));
    src.dispatchEvent(new Event('input',{bubbles:true}));
    lock=false;
  };
  num.addEventListener('input',push);
  range.addEventListener('input',()=&gt;{num.value=range.value;push();});
})();

function bindStrokeOptionGroup(selector, cb){
  document.querySelectorAll(selector).forEach(btn =&gt; {
    btn.addEventListener('click',()=&gt;{
      const group=btn.parentElement?.querySelectorAll(selector) || [];
      group.forEach(x=&gt;x.classList.remove('active'));
      btn.classList.add('active');
      cb?.(btn.dataset);
    });
  });
}
bindStrokeOptionGroup('[data-stroke-cap]', data =&gt; {
  const obj=activeObj(); if(!obj) return;
  obj.set({strokeLineCap:data.strokeCap}); canvas.requestRenderAll();
});
bindStrokeOptionGroup('[data-stroke-join]', data =&gt; {
  const obj=activeObj(); if(!obj) return;
  obj.set({strokeLineJoin:data.strokeJoin}); canvas.requestRenderAll();
});

$('btnHelp')?.addEventListener('click', () =&gt; {
  openModal('Atalhos de teclado', `
    &lt;div class="shortcuts-grid" style="gap:8px 16px"&gt;
      &lt;span class="sc-key"&gt;Ctrl+Z&lt;/span&gt;&lt;span class="sc-desc"&gt;Desfazer&lt;/span&gt;
      &lt;span class="sc-key"&gt;Ctrl+Shift+Z&lt;/span&gt;&lt;span class="sc-desc"&gt;Refazer&lt;/span&gt;
      &lt;span class="sc-key"&gt;V&lt;/span&gt;&lt;span class="sc-desc"&gt;Ferramenta seleção&lt;/span&gt;
      &lt;span class="sc-key"&gt;A&lt;/span&gt;&lt;span class="sc-desc"&gt;Seleção direta de nós&lt;/span&gt;
      &lt;span class="sc-key"&gt;Ctrl+D&lt;/span&gt;&lt;span class="sc-desc"&gt;Duplicar&lt;/span&gt;
      &lt;span class="sc-key"&gt;Ctrl+G&lt;/span&gt;&lt;span class="sc-desc"&gt;Agrupar seleção&lt;/span&gt;
      &lt;span class="sc-key"&gt;Ctrl+Shift+G&lt;/span&gt;&lt;span class="sc-desc"&gt;Desagrupar seleção&lt;/span&gt;
      &lt;span class="sc-key"&gt;Del&lt;/span&gt;&lt;span class="sc-desc"&gt;Apagar seleção&lt;/span&gt;
      &lt;span class="sc-key"&gt;Espaço&lt;/span&gt;&lt;span class="sc-desc"&gt;Arrastar viewport&lt;/span&gt;
      &lt;span class="sc-key"&gt;Scroll&lt;/span&gt;&lt;span class="sc-desc"&gt;Zoom suave&lt;/span&gt;
      &lt;span class="sc-key"&gt;Botão do meio&lt;/span&gt;&lt;span class="sc-desc"&gt;Pan&lt;/span&gt;
    &lt;/div&gt;
  `);
});

// ─── postMessage (brand data from parent) ────────────────
window.addEventListener('message', ev =&gt; {
  const msg = ev.data || {};
  if (msg.type === 'setDoc') {
    setArtboardSize(Number(msg.w)||docW, Number(msg.h)||docH);
    if (msg.fit) fitToArtboard();
  }
  if (msg.type === 'fit') fitToArtboard();
  if (msg.type === 'exportPNG') exportPNG();
  if (msg.type === 'exportSVG') exportSVGToParent();
  if (msg.type === 'setSVG') loadSVGFromParent(msg.svg);
  if (msg.type === 'setBrand') {
    if (Array.isArray(msg.library)) {
      brandLibrary = msg.library.slice(0,80);
      refreshLibrary();
    }
    if (Array.isArray(msg.fonts) &amp;&amp; UI.font) {
      const existing = new Set(Array.from(UI.font.options).map(o=&gt;o.value));
      msg.fonts.forEach(f =&gt; {
        const ff = String(f||'').trim();
        if(!ff||existing.has(ff)) return;
        const opt = document.createElement('option');
        opt.value = ff; opt.textContent = ff;
        UI.font.appendChild(opt); existing.add(ff);
      });
    }
  }
  if (msg.type === 'geSetApplicationMeta') {
    const nameInput = $('projectNameInline');
    if (nameInput &amp;&amp; msg.name) nameInput.value = msg.name;
    const info = $('docInfoLabel');
    if (info) info.textContent = `${msg.modeLabel || 'Web'} • ${msg.width || 0}×${msg.height || 0}${msg.unit || 'px'} • ${msg.dpi || 72}dpi`;
  }
});

// ─── Boot ────────────────────────────────────────────────
function boot() {
  requestAnimationFrame(() =&gt; requestAnimationFrame(() =&gt; {
    resizeCanvasToViewport();
    setDeskBg(deskBg);
    setDeskTheme('nebula');
    ensureArtboard();
    fitToArtboard();
    updateZoomLabel();
    updateArtboardPlusUI();
    refreshLibrary();

    const ro = new ResizeObserver(() =&gt; {
      resizeCanvasToViewport();
      fitToArtboard();
      updateArtboardPlusUI();
    });
    ro.observe(stageEl);
    window.addEventListener('resize', () =&gt; { resizeCanvasToViewport(); fitToArtboard(); updateArtboardPlusUI(); });
    snapshot();

    const inlineNameInput = $('projectNameInline');
    if (inlineNameInput) {
      const syncName = () =&gt; {
        const nm = String(inlineNameInput.value || '').trim();
        if (!nm) return;
        window.parent.postMessage({ type: 'geRenameApplication', name: nm }, '*');
      };
      let nameTimer;
      inlineNameInput.addEventListener('input', () =&gt; {
        clearTimeout(nameTimer);
        nameTimer = setTimeout(syncName, 260);
      });
      inlineNameInput.addEventListener('blur', syncName);
      inlineNameInput.addEventListener('keydown', e =&gt; {
        if (e.key === 'Enter') { e.preventDefault(); inlineNameInput.blur(); }
      });
    }
  }));
}
boot();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</template>

<style>
  .ge-onecol{ grid-template-columns: 1fr !important; }
  .ge-iframeWrap{ min-height:0; height:100%; padding:0; display:flex; flex-direction:column; overflow:hidden; }
  .ge-iframeWrap iframe{ flex:1; min-height:0; width:100%; border:0; display:block; }
</style>

<script src="script.js"></script>
</body>
</html>
